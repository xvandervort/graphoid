# SQL Query Module - Pure Glang implementation
# Treats tables as lazy collections that build query graphs

# Create a table reference - returns a query node
func Table(name) {
    query = {
        "table_name": name,
        "conditions": [],
        "orderings": [],
        "limit_value": none
    }
    return query
}

# Add a filter condition - returns new query node
func filter(query, condition) {
    # Create a shallow copy of the lists
    conditions_copy = []
    for c in query["conditions"] {
        conditions_copy.append(c)
    }
    orderings_copy = []
    for o in query["orderings"] {
        orderings_copy.append(o)
    }

    new_query = {
        "table_name": query["table_name"],
        "conditions": conditions_copy,
        "orderings": orderings_copy,
        "limit_value": query["limit_value"]
    }
    new_query["conditions"].append(condition)
    return new_query
}

# Alias for filter
func where(query, condition) {
    return filter(query, condition)
}

# Add sorting - returns new query node
func sort(query, field) {
    # Create a shallow copy of the lists
    conditions_copy = []
    for c in query["conditions"] {
        conditions_copy.append(c)
    }
    orderings_copy = []
    for o in query["orderings"] {
        orderings_copy.append(o)
    }

    new_query = {
        "table_name": query["table_name"],
        "conditions": conditions_copy,
        "orderings": orderings_copy,
        "limit_value": query["limit_value"]
    }
    ordering = { "field": field, "direction": "ASC" }
    new_query["orderings"].append(ordering)
    return new_query
}

# Add descending sort - returns new query node
func sort_desc(query, field) {
    # Create a shallow copy of the lists
    conditions_copy = []
    for c in query["conditions"] {
        conditions_copy.append(c)
    }
    orderings_copy = []
    for o in query["orderings"] {
        orderings_copy.append(o)
    }

    new_query = {
        "table_name": query["table_name"],
        "conditions": conditions_copy,
        "orderings": orderings_copy,
        "limit_value": query["limit_value"]
    }
    ordering = { "field": field, "direction": "DESC" }
    new_query["orderings"].append(ordering)
    return new_query
}

# Set limit - returns new query node
func limit(query, count) {
    # Create a shallow copy of the lists
    conditions_copy = []
    for c in query["conditions"] {
        conditions_copy.append(c)
    }
    orderings_copy = []
    for o in query["orderings"] {
        orderings_copy.append(o)
    }

    new_query = {
        "table_name": query["table_name"],
        "conditions": conditions_copy,
        "orderings": orderings_copy,
        "limit_value": count
    }
    return new_query
}

# Alias for limit
func take(query, count) {
    return limit(query, count)
}

# Generate SQL from query node
func to_sql(query) {
    sql = "SELECT * FROM " + query["table_name"]

    # Add WHERE clause if there are conditions
    if query["conditions"].size() > 0 {
        sql = sql + " WHERE "
        # Inline join strings logic
        if query["conditions"].size() == 1 {
            sql = sql + query["conditions"][0]
        } else {
            result = query["conditions"][0]
            i = 1
            while i < query["conditions"].size() {
                result = result + " AND " + query["conditions"][i]
                i = i + 1
            }
            sql = sql + result
        }
    }

    # Add ORDER BY clause if there are orderings
    if query["orderings"].size() > 0 {
        sql = sql + " ORDER BY "
        order_parts = []
        for ordering in query["orderings"] {
            part = ordering["field"] + " " + ordering["direction"]
            order_parts.append(part)
        }
        # Inline join logic for order parts
        if order_parts.size() == 1 {
            sql = sql + order_parts[0]
        } else {
            result = order_parts[0]
            i = 1
            while i < order_parts.size() {
                result = result + ", " + order_parts[i]
                i = i + 1
            }
            sql = sql + result
        }
    }

    # Add LIMIT clause if specified
    if query["limit_value"] != none {
        sql = sql + " LIMIT " + query["limit_value"].to_string()
    }

    return sql
}

# Convenience functions for building conditions
func eq(field, value) {
    if value.type == "string" {
        return field + " = '" + value + "'"
    }
    return field + " = " + value.to_string()
}

func gt(field, value) {
    if value.type == "string" {
        return field + " > '" + value + "'"
    }
    return field + " > " + value.to_string()
}

func lt(field, value) {
    if value.type == "string" {
        return field + " < '" + value + "'"
    }
    return field + " < " + value.to_string()
}

func gte(field, value) {
    if value.type == "string" {
        return field + " >= '" + value + "'"
    }
    return field + " >= " + value.to_string()
}

func lte(field, value) {
    if value.type == "string" {
        return field + " <= '" + value + "'"
    }
    return field + " <= " + value.to_string()
}

func like(field, pattern) {
    return field + " LIKE '" + pattern + "'"
}

func in_list(field, values) {
    value_parts = []
    for v in values {
        if v.type == "string" {
            value_parts.append("'" + v + "'")
        } else {
            value_parts.append(v.to_string())
        }
    }

    # Inline join logic
    if value_parts.size() == 0 {
        return field + " IN ()"
    }

    joined = value_parts[0]
    i = 1
    while i < value_parts.size() {
        joined = joined + ", " + value_parts[i]
        i = i + 1
    }

    return field + " IN (" + joined + ")"
}