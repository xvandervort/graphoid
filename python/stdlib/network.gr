# Clean Network Library for Glang - Maximizing Pure Glang Implementation
module network

# URL parsing function - pure Glang
func parse_url(url) {
    if url.contains("://") == false {
        return { "error": "Invalid URL: missing protocol" }
    }

    protocol_parts = url.split("://")
    if protocol_parts.size() != 2 {
        return { "error": "Invalid URL format" }
    }

    protocol = protocol_parts[0]
    rest = protocol_parts[1]

    path_parts = rest.split("/")
    host = path_parts[0]

    path = "/"
    if path_parts.size() > 1 {
        path_segments = []
        i = 1
        while i < path_parts.size() {
            path_segments.append(path_parts[i])
            i = i + 1
        }
        if path_segments.size() > 0 {
            path = "/" + "/".join(path_segments)
        }
    }

    return {
        "protocol": protocol,
        "host": host,
        "path": path,
        "url": url
    }
}

# URL encoding - pure Glang with safe character replacement
func encode_url(text) {
    result = text
    # Order matters: % must be first to avoid double-encoding
    result = result.replace("%", "%25")
    result = result.replace(" ", "%20")
    result = result.replace("&", "%26")
    result = result.replace("=", "%3D")

    # Skip problematic regex characters for now
    # TODO: Fix when Glang has better string replacement
    # result = result.replace("?", "%3F")  # ? is regex special
    # result = result.replace("#", "%23")  # Safe
    # result = result.replace("+", "%2B")  # + is regex special
    # result = result.replace("/", "%2F")  # Safe

    return result
}

# URL decoding - pure Glang
func decode_url(text) {
    result = text
    result = result.replace("%20", " ")
    result = result.replace("%26", "&")
    result = result.replace("%3D", "=")
    result = result.replace("%3F", "?")
    result = result.replace("%23", "#")
    result = result.replace("%2B", "+")
    result = result.replace("%2F", "/")
    result = result.replace("%25", "%")
    return result
}

# Extract domain from URL - pure Glang
func extract_domain(url) {
    parsed = parse_url(url)
    if parsed.has_key("error") {
        return ""
    }

    host = parsed["host"]

    if host.contains(":") {
        host = host.split(":")[0]
    }

    if host.starts_with("www.") {
        domain_parts = host.split(".")
        if domain_parts.size() > 1 {
            remaining = []
            i = 1
            while i < domain_parts.size() {
                remaining.append(domain_parts[i])
                i = i + 1
            }
            host = ".".join(remaining)
        }
    }

    return host
}

# Check if URL is valid - pure Glang
func is_valid_url(url) {
    # Simple validation: URL must contain protocol separator
    if url.contains("://") == false {
        return false
    }

    # Additional check: must have valid protocol and host parts
    parts = url.split("://")
    if parts.size() != 2 {
        return false
    }

    if parts[0] == "" {
        return false
    }

    if parts[1] == "" {
        return false
    }

    return true
}

# HTTP operations - High-level API using built-in HTTP module
import "http"

func http_get(url) {
    if is_valid_url(url) == false {
        return { "error": "Invalid URL: " + url, "status": 0, "success": false }
    }

    return http.get(url)
}

func http_post(url, post_data) {
    if is_valid_url(url) == false {
        return { "error": "Invalid URL: " + url, "status": 0, "success": false }
    }

    return http.post(url, post_data)
}

func http_request(method, url, post_data, request_headers) {
    if is_valid_url(url) == false {
        return { "error": "Invalid URL: " + url, "status": 0, "success": false }
    }

    return http.request(method, url, post_data, request_headers)
}

func download_file(url, filepath) {
    if is_valid_url(url) == false {
        return false
    }

    return http.download_file(url, filepath)
}

# Convenience wrapper for simple GET requests with error handling
func fetch(url) {
    response = http_get(url)

    if response.has_key("success") and response["success"] == true {
        return response["body"]
    } else {
        return ""
    }
}

# Check if network is available
func is_network_available() {
    return http.is_available()
}