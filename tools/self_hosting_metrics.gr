import "io" as io

string REPO_ROOT = "."
string PYTHON_SRC = "src/glang"
string STDLIB_DIR = "stdlib"
string SAMPLES_DIR = "samples"

num PURE_THRESHOLD = 1
num HYBRID_THRESHOLD = 5

func count_file_lines(filepath) {
    handle = io.open(filepath, "r")
    content = handle.read()

    if content == "" {
        return 0
    }

    lines = content.split("\n")
    count = 0

    for line in lines {
        trimmed = line.trim()
        if trimmed != "" {
            is_comment = trimmed.starts_with("#")
            if not is_comment {
                count = count + 1
            }
        }
    }

    return count
}

func classify_module(filepath) {
    handle = io.open(filepath, "r")
    content = handle.read()

    if content == "" {
        return "empty"
    }

    builtin_count = content.count_chars("_builtin_")
    import_count = content.count_chars("import \"")

    if content.contains("http.") {
        builtin_count = builtin_count + 5
    }
    if content.contains("html_parser.") {
        builtin_count = builtin_count + 5
    }
    if content.contains("io.open") {
        builtin_count = builtin_count + 2
    }

    if builtin_count == 0 and import_count <= 1 {
        return "pure"
    }
    if builtin_count < HYBRID_THRESHOLD {
        return "hybrid"
    }
    return "wrapper"
}

func analyze_modules() {
    stdlib_files = io.find_files("stdlib", "*.gr")
    pure_count = 0
    hybrid_count = 0
    wrapper_count = 0

    for filepath in stdlib_files {
        classification = classify_module(filepath)
        if classification == "pure" {
            pure_count = pure_count + 1
        }
        if classification == "hybrid" {
            hybrid_count = hybrid_count + 1
        }
        if classification == "wrapper" {
            wrapper_count = wrapper_count + 1
        }
    }

    total_modules = pure_count + hybrid_count + wrapper_count
    mir = 0
    if total_modules > 0 {
        mir = (pure_count * 100 / total_modules)
    }

    return [mir, pure_count, hybrid_count, wrapper_count, total_modules]
}

func calculate_metrics() {
    print("============================================================")
    print("ðŸŽ¯ GLANG SELF-HOSTING PROGRESS REPORT")
    print("============================================================")
    print("")

    python_lines = io.count_lines_recursive("src", "py")
    stdlib_lines = io.count_lines_recursive("stdlib", "gr")
    samples_lines = io.count_lines_recursive("samples", "gr")

    total_core_lines = python_lines + stdlib_lines

    module_results = analyze_modules()
    mir = module_results[0]
    pure_count = module_results[1]
    hybrid_count = module_results[2]
    wrapper_count = module_results[3]
    total_modules = module_results[4]

    precision 2 {
        lcr = (stdlib_lines * 100 / total_core_lines)
        overall_progress = (lcr + mir) / 2
        remaining = 80 - overall_progress

        print("ðŸ“Š OVERALL SELF-HOSTING PROGRESS: " + overall_progress.to_string() + "%")
        print("")
        print("ðŸŽ¯ TARGET: 80% self-hosting by Q2 2025 (Rust migration)")
        print("ðŸ“ˆ REMAINING: " + remaining.to_string() + "% to reach target")
        print("")

        print("ðŸ“ DETAILED BREAKDOWN:")
        print("  Lines of Code Ratio (LCR):     " + lcr.to_string() + "%")
        print("    â€¢ Python Backend:             " + python_lines.to_string() + " lines")
        print("    â€¢ Glang Standard Library:     " + stdlib_lines.to_string() + " lines")
        print("    â€¢ Glang Examples/Samples:     " + samples_lines.to_string() + " lines")
        print("")

        print("  Module Implementation Ratio:   " + mir.to_string() + "%")
        print("    â€¢ Pure Glang modules:         " + pure_count.to_string() + "/" + total_modules.to_string())
        print("    â€¢ Hybrid modules:             " + hybrid_count.to_string() + "/" + total_modules.to_string())
        print("    â€¢ Python wrapper modules:     " + wrapper_count.to_string() + "/" + total_modules.to_string())
        print("")
    }

    overall_progress_stored = overall_progress

    print("ðŸš€ NEXT PRIORITIES TO INCREASE SELF-HOSTING:")
    print("")

    if wrapper_count > 0 {
        print("  ðŸ“¦ CONVERT " + wrapper_count.to_string() + " WRAPPER MODULES TO PURE GLANG:")
        wrapper_files = io.find_files("stdlib", "*.gr")
        for filepath in wrapper_files {
            classification = classify_module(filepath)
            if classification == "wrapper" {
                filename = io.basename(filepath)
                print("    â€¢ " + filename + " (high-impact conversion)")
            }
        }
        print("")
    }

    precision 2 {
        lcr_stored = lcr
    }

    if lcr_stored < 15 {
        print("  ðŸ“ˆ INCREASE GLANG STANDARD LIBRARY:")
        precision 0 {
            needed_lines = (python_lines * 15 / 100) - stdlib_lines
            print("    â€¢ Write ~" + needed_lines.to_string() + " more lines of Glang stdlib code")
        }
        print("    â€¢ Focus on core utilities, data structures, algorithms")
        print("    â€¢ Implement missing language features in pure Glang")
        print("")
    }

    print("  ðŸŽ¯ MILESTONE TARGETS:")
    if overall_progress_stored >= 80 {
        print("    ðŸŽ‰ READY FOR RUST MIGRATION!")
    } else {
        if overall_progress_stored >= 60 {
            print("    âœ… 60%+ Self-hosting (excellent progress)")
        }
        if overall_progress_stored >= 40 {
            print("    âœ… 40%+ Self-hosting (good foundation)")
        }

        weeks_to_60 = (60 - overall_progress_stored) * 1.5
        weeks_to_80 = (80 - overall_progress_stored) * 2
        precision 1 {
            if overall_progress_stored < 60 {
                print("    ðŸ“… ~" + weeks_to_60.to_string() + " weeks to 60% (major milestone)")
            }
            print("    ðŸ“… ~" + weeks_to_80.to_string() + " weeks to 80% (Rust migration ready)")
        }
    }
}

calculate_metrics()