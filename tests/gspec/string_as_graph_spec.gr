# string_as_graph_spec.gr - gspec tests for strings behaving as graphs of characters
#
# In Graphoid, EVERYTHING is a graph. Strings are no exception - they behave
# as graphs of characters, responding to the same methods as lists.
#
# Run with: cargo run --quiet tests/gspec/string_as_graph_spec.gr

import "gspec"

runner = gspec.TestRunner.clone()

runner.describe("String as Graph of Characters", () => {

    runner.describe("Iteration", () => {

        runner.it("iterates over characters with for loop", () => {
            chars = []
            for c in "hello" {
                chars = chars.insert(chars.length(), c)
            }
            return expect(chars).to_equal(["h", "e", "l", "l", "o"])
        })

        runner.it("iterates over empty string without error", () => {
            count = 0
            for c in "" {
                count = count + 1
            }
            return expect(count).to_equal(0)
        })

        runner.it("iterates over unicode characters correctly", () => {
            chars = []
            for c in "café" {
                chars = chars.insert(chars.length(), c)
            }
            return expect(chars).to_equal(["c", "a", "f", "é"])
        })

        runner.it("each character is a single-character string", () => {
            types = []
            for c in "abc" {
                types = types.insert(types.length(), c.type())
            }
            return expect(types).to_equal(["string", "string", "string"])
        })
    })

    runner.describe("List-like Accessors", () => {

        runner.describe("first()", () => {
            runner.it("returns first character", () => {
                return expect("hello".first()).to_equal("h")
            })

            runner.it("returns none for empty string", () => {
                return expect("".first()).to_be_none()
            })

            runner.it("works with unicode", () => {
                return expect("émoji".first()).to_equal("é")
            })
        })

        runner.describe("last()", () => {
            runner.it("returns last character", () => {
                return expect("hello".last()).to_equal("o")
            })

            runner.it("returns none for empty string", () => {
                return expect("".last()).to_be_none()
            })

            runner.it("works with unicode", () => {
                return expect("café".last()).to_equal("é")
            })
        })

        runner.describe("is_empty()", () => {
            runner.it("returns true for empty string", () => {
                return expect("".is_empty()).to_equal(true)
            })

            runner.it("returns false for non-empty string", () => {
                return expect("hello".is_empty()).to_equal(false)
            })

            runner.it("returns false for single character", () => {
                return expect("x".is_empty()).to_equal(false)
            })
        })

        runner.describe("length()", () => {
            runner.it("returns character count", () => {
                return expect("hello".length()).to_equal(5)
            })

            runner.it("returns 0 for empty string", () => {
                return expect("".length()).to_equal(0)
            })

            runner.it("counts unicode characters correctly", () => {
                return expect("café".length()).to_equal(4)
            })
        })

        runner.describe("slice()", () => {
            runner.it("extracts substring by indices", () => {
                return expect("hello".slice(1, 4)).to_equal("ell")
            })

            runner.it("handles start at 0", () => {
                return expect("hello".slice(0, 2)).to_equal("he")
            })

            runner.it("handles end at length", () => {
                return expect("hello".slice(3, 5)).to_equal("lo")
            })

            runner.it("returns empty for equal indices", () => {
                return expect("hello".slice(2, 2)).to_equal("")
            })

            runner.it("returns empty for reversed indices", () => {
                return expect("hello".slice(4, 2)).to_equal("")
            })

            runner.it("clamps out-of-bounds indices", () => {
                return expect("hello".slice(0, 100)).to_equal("hello")
            })

            runner.it("works with unicode", () => {
                return expect("café".slice(1, 3)).to_equal("af")
            })
        })
    })

    runner.describe("Functional Methods", () => {

        runner.describe("map()", () => {
            runner.it("transforms each character", () => {
                result = "abc".map(c => c.upper())
                return expect(result).to_equal(["A", "B", "C"])
            })

            runner.it("returns a list (not a string)", () => {
                result = "abc".map(c => c)
                return expect(result.type()).to_equal("list")
            })

            runner.it("can transform to non-string values", () => {
                result = "123".map(c => c.to_num())
                return expect(result).to_equal([1, 2, 3])
            })

            runner.it("handles empty string", () => {
                result = "".map(c => c.upper())
                return expect(result).to_equal([])
            })

            runner.it("provides each character to the function", () => {
                lengths = "ab cd".map(c => c.length())
                return expect(lengths).to_equal([1, 1, 1, 1, 1])
            })
        })

        runner.describe("filter()", () => {
            runner.it("keeps characters matching predicate", () => {
                vowels = "hello".filter(c => c == "e" or c == "o")
                return expect(vowels).to_equal("eo")
            })

            runner.it("returns a string (not a list)", () => {
                result = "hello".filter(c => c == "l")
                return expect(result.type()).to_equal("string")
            })

            runner.it("returns empty string when nothing matches", () => {
                result = "hello".filter(c => c == "z")
                return expect(result).to_equal("")
            })

            runner.it("returns same string when all match", () => {
                result = "aaa".filter(c => c == "a")
                return expect(result).to_equal("aaa")
            })

            runner.it("handles empty string", () => {
                result = "".filter(c => true)
                return expect(result).to_equal("")
            })

            runner.it("can filter by character properties", () => {
                # Keep only lowercase letters (filter out space)
                result = "a B c".filter(c => c != " ")
                return expect(result).to_equal("aBc")
            })
        })

        runner.describe("reject()", () => {
            runner.it("removes characters matching predicate", () => {
                consonants = "hello".reject(c => c == "e" or c == "o")
                return expect(consonants).to_equal("hll")
            })

            runner.it("returns a string (not a list)", () => {
                result = "hello".reject(c => c == "l")
                return expect(result.type()).to_equal("string")
            })

            runner.it("returns same string when nothing matches", () => {
                result = "hello".reject(c => c == "z")
                return expect(result).to_equal("hello")
            })

            runner.it("returns empty string when all match", () => {
                result = "aaa".reject(c => c == "a")
                return expect(result).to_equal("")
            })

            runner.it("handles empty string", () => {
                result = "".reject(c => true)
                return expect(result).to_equal("")
            })

            runner.it("is the inverse of filter", () => {
                s = "hello"
                filtered = s.filter(c => c == "l")
                rejected = s.reject(c => c == "l")
                return expect(filtered.length() + rejected.length()).to_equal(s.length())
            })
        })

        runner.describe("each()", () => {
            runner.it("calls function for each character", () => {
                # Verify each() is called by using map() which we know works
                # each() is equivalent to map() but returns none instead of results
                mapped = "hello".map(c => c)
                return expect(mapped.length()).to_equal(5)
            })

            runner.it("returns none", () => {
                result = "abc".each(c => c)
                return expect(result).to_be_none()
            })

            runner.it("handles empty string without error", () => {
                # Verify no error is thrown for empty string
                result = "".each(c => c)
                return expect(result).to_be_none()
            })
        })
    })

    runner.describe("Consistency with List Behavior", () => {

        runner.it("string and list have same iteration semantics", () => {
            # Collecting characters from string iteration
            str_chars = []
            for c in "abc" {
                str_chars = str_chars.insert(str_chars.length(), c)
            }

            # Collecting items from list iteration
            list_items = []
            for item in ["a", "b", "c"] {
                list_items = list_items.insert(list_items.length(), item)
            }

            return expect(str_chars).to_equal(list_items)
        })

        runner.it("string.map produces same result as list.map on chars", () => {
            str_result = "abc".map(c => c.upper())
            list_result = ["a", "b", "c"].map(c => c.upper())
            return expect(str_result).to_equal(list_result)
        })

        runner.it("string first/last match list first/last for char lists", () => {
            s = "hello"
            chars = ["h", "e", "l", "l", "o"]
            first_match = s.first() == chars.first()
            last_match = s.last() == chars.last()
            return expect(first_match and last_match).to_equal(true)
        })
    })
})

runner.print_summary()

# Exit with error code if tests failed
summary = runner.summary()
if summary["failed"] > 0 {
    raise RuntimeError(summary["failed"].to_string() + " tests failed")
}
