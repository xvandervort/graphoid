# universe_graph_spec.gr - gspec tests for Phase 18: Persistent Universe Graph
#
# Covers: type hierarchy, module nodes, import edges,
#         reflect.type_hierarchy(), graph.has_node()
#
# Run with: gr spec tests/gspec/universe_graph_spec.gr

describe "universe graph type hierarchy" {
    it "has type:any node" {
        u = reflect.universe()
        assert(expect(u.has_node("type:any")).to_be_truthy())
    }

    it "has type:int node" {
        u = reflect.universe()
        assert(expect(u.has_node("type:int")).to_be_truthy())
    }

    it "has type:collection node" {
        u = reflect.universe()
        assert(expect(u.has_node("type:collection")).to_be_truthy())
    }

    it "has scope:main node" {
        u = reflect.universe()
        assert(expect(u.has_node("scope:main")).to_be_truthy())
    }

    it "int is subtype of num" {
        u = reflect.universe()
        assert(expect(u.has_path("type:int", "type:num")).to_be_truthy())
    }

    it "int has path to any (via num)" {
        u = reflect.universe()
        assert(expect(u.has_path("type:int", "type:any")).to_be_truthy())
    }

    it "list is subtype of collection" {
        u = reflect.universe()
        assert(expect(u.has_path("type:list", "type:collection")).to_be_truthy())
    }

    it "string is not subtype of num" {
        u = reflect.universe()
        result = u.has_path("type:string", "type:num")
        assert(expect(result).to_equal(false))
    }

    it "has 17 type nodes" {
        u = reflect.universe()
        types = ["type:any", "type:num", "type:int", "type:float", "type:bignum",
                 "type:string", "type:bool", "type:none", "type:symbol",
                 "type:collection", "type:list", "type:map", "type:graph",
                 "type:function", "type:module", "type:error", "type:time"]
        count = 0
        for t in types {
            if u.has_node(t) {
                count = count + 1
            }
        }
        assert(expect(count).to_equal(17))
    }
}

describe "reflect.type_hierarchy" {
    it "returns a graph" {
        th = reflect.type_hierarchy()
        assert(expect(th.type()).to_equal("graph"))
    }

    it "contains type nodes" {
        th = reflect.type_hierarchy()
        assert(expect(th.has_node("type:int")).to_be_truthy())
        assert(expect(th.has_node("type:any")).to_be_truthy())
    }

    it "does not contain scope:main" {
        th = reflect.type_hierarchy()
        result = th.has_node("scope:main")
        assert(expect(result).to_equal(false))
    }

    it "preserves subtype edges" {
        th = reflect.type_hierarchy()
        assert(expect(th.has_path("type:float", "type:any")).to_be_truthy())
    }
}

describe "graph.has_node" {
    it "returns true for existing node" {
        g = graph { type: :directed }
        g.add_node("A", 1)
        assert(expect(g.has_node("A")).to_be_truthy())
    }

    it "returns false for missing node" {
        g = graph { type: :directed }
        result = g.has_node("Z")
        assert(expect(result).to_equal(false))
    }
}
