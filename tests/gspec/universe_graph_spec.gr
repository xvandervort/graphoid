# universe_graph_spec.gr - gspec tests for Phase 18: Persistent Universe Graph
#
# Covers: type hierarchy, module nodes, import edges,
#         reflect.type_hierarchy(), graph.has_node()
#
# Run with: gr spec tests/gspec/universe_graph_spec.gr

describe "universe graph type hierarchy" {
    it "has type:any node" {
        u = reflect.universe()
        assert(expect(u.has_node("type:any")).to_be_truthy())
    }

    it "has type:int node" {
        u = reflect.universe()
        assert(expect(u.has_node("type:int")).to_be_truthy())
    }

    it "has type:collection node" {
        u = reflect.universe()
        assert(expect(u.has_node("type:collection")).to_be_truthy())
    }

    it "has scope:main node" {
        u = reflect.universe()
        assert(expect(u.has_node("scope:main")).to_be_truthy())
    }

    it "int is subtype of num" {
        u = reflect.universe()
        assert(expect(u.has_path("type:int", "type:num")).to_be_truthy())
    }

    it "int has path to any (via num)" {
        u = reflect.universe()
        assert(expect(u.has_path("type:int", "type:any")).to_be_truthy())
    }

    it "list is subtype of collection" {
        u = reflect.universe()
        assert(expect(u.has_path("type:list", "type:collection")).to_be_truthy())
    }

    it "string is not subtype of num" {
        u = reflect.universe()
        result = u.has_path("type:string", "type:num")
        assert(expect(result).to_equal(false))
    }

    it "has 17 type nodes" {
        u = reflect.universe()
        types = ["type:any", "type:num", "type:int", "type:float", "type:bignum",
                 "type:string", "type:bool", "type:none", "type:symbol",
                 "type:collection", "type:list", "type:map", "type:graph",
                 "type:function", "type:module", "type:error", "type:time"]
        count = 0
        for t in types {
            if u.has_node(t) {
                count = count + 1
            }
        }
        assert(expect(count).to_equal(17))
    }
}

describe "reflect.type_hierarchy" {
    it "returns a graph" {
        th = reflect.type_hierarchy()
        assert(expect(th.type()).to_equal("graph"))
    }

    it "contains type nodes" {
        th = reflect.type_hierarchy()
        assert(expect(th.has_node("type:int")).to_be_truthy())
        assert(expect(th.has_node("type:any")).to_be_truthy())
    }

    it "does not contain scope:main" {
        th = reflect.type_hierarchy()
        result = th.has_node("scope:main")
        assert(expect(result).to_equal(false))
    }

    it "preserves subtype edges" {
        th = reflect.type_hierarchy()
        assert(expect(th.has_path("type:float", "type:any")).to_be_truthy())
    }
}

describe "universe module nodes" {
    it "has module node after import" {
        import "math"
        u = reflect.universe()
        assert(expect(u.has_node("module:math")).to_be_truthy())
    }

    it "has import edge after import" {
        import "math"
        u = reflect.universe()
        assert(expect(u.has_path("scope:main", "module:math")).to_be_truthy())
    }
}

describe "graph templates in universe" {
    it "has graph:Name node after declaration" {
        graph Person {
            name: "unnamed"
        }
        u = reflect.universe()
        assert(expect(u.has_node("graph:Person")).to_be_truthy())
    }

    it "graph template is subtype of type:graph" {
        graph Animal {
            name: "unnamed"
        }
        u = reflect.universe()
        assert(expect(u.has_path("graph:Animal", "type:graph")).to_be_truthy())
    }

    it "child graph is subtype of parent" {
        graph Vehicle {
            speed: 0
        }
        graph Car from Vehicle {
            doors: 4
        }
        u = reflect.universe()
        assert(expect(u.has_path("graph:Car", "graph:Vehicle")).to_be_truthy())
    }
}

describe "behaviors via configure" {
    it "applies rule from configure block" {
        graph DAG {
            configure { behaviors: [:no_cycles] }
        }
        assert(expect(DAG.has_rule(:no_cycles)).to_be_truthy())
    }
}

describe "exception type hierarchy" {
    it "has error type nodes in universe" {
        u = reflect.universe()
        assert(expect(u.has_node("error:ValueError")).to_be_truthy())
        assert(expect(u.has_node("error:IOError")).to_be_truthy())
        assert(expect(u.has_node("error:FileError")).to_be_truthy())
    }

    it "FileError is subtype of IOError" {
        u = reflect.universe()
        assert(expect(u.has_path("error:FileError", "error:IOError")).to_be_truthy())
    }

    it "IOError is subtype of type:error" {
        u = reflect.universe()
        assert(expect(u.has_path("error:IOError", "type:error")).to_be_truthy())
    }

    it "ValueError is not subtype of IOError" {
        u = reflect.universe()
        result = u.has_path("error:ValueError", "error:IOError")
        assert(expect(result).to_equal(false))
    }

    it "catch IOError catches FileError" {
        result = "not caught"
        try {
            raise("FileError: test file error")
        } catch IOError as e {
            result = "caught: " + e.type()
        }
        assert(expect(result).to_equal("caught: FileError"))
    }

    it "catch ValueError does not catch IOError" {
        result = "not caught"
        try {
            raise("IOError: test io error")
        } catch ValueError as e {
            result = "caught ValueError"
        } catch as e {
            result = "caught generic"
        }
        assert(expect(result).to_equal("caught generic"))
    }
}

describe "graph.has_node" {
    it "returns true for existing node" {
        g = graph { type: :directed }
        g.add_node("A", 1)
        assert(expect(g.has_node("A")).to_be_truthy())
    }

    it "returns false for missing node" {
        g = graph { type: :directed }
        result = g.has_node("Z")
        assert(expect(result).to_equal(false))
    }
}
