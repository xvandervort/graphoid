# universe_graph_spec.gr - gspec tests for Phase 18: Persistent Universe Graph
#
# Covers: type hierarchy, module nodes, import edges,
#         reflect.type_hierarchy(), graph.has_node()
#
# Run with: gr spec tests/gspec/universe_graph_spec.gr

describe "universe graph type hierarchy" {
    it "has type:any node" {
        u = reflect.universe()
        assert(expect(u.has_node("type:any")).to_be_truthy())
    }

    it "has type:num node" {
        u = reflect.universe()
        assert(expect(u.has_node("type:num")).to_be_truthy())
    }

    it "has type:collection node" {
        u = reflect.universe()
        assert(expect(u.has_node("type:collection")).to_be_truthy())
    }

    it "has scope:main node" {
        u = reflect.universe()
        assert(expect(u.has_node("scope:main")).to_be_truthy())
    }

    it "bignum is subtype of num" {
        u = reflect.universe()
        assert(expect(u.has_path("type:bignum", "type:num")).to_be_truthy())
    }

    it "num has path to any" {
        u = reflect.universe()
        assert(expect(u.has_path("type:num", "type:any")).to_be_truthy())
    }

    it "list is subtype of collection" {
        u = reflect.universe()
        assert(expect(u.has_path("type:list", "type:collection")).to_be_truthy())
    }

    it "string is not subtype of num" {
        u = reflect.universe()
        result = u.has_path("type:string", "type:num")
        assert(expect(result).to_equal(false))
    }

    it "has 15 type nodes" {
        u = reflect.universe()
        types = ["type:any", "type:num", "type:bignum",
                 "type:string", "type:bool", "type:none", "type:symbol",
                 "type:collection", "type:list", "type:map", "type:graph",
                 "type:function", "type:module", "type:error", "type:time"]
        count = 0
        for t in types {
            if u.has_node(t) {
                count = count + 1
            }
        }
        assert(expect(count).to_equal(15))
    }
}

describe "reflect.type_hierarchy" {
    it "returns a graph" {
        th = reflect.type_hierarchy()
        assert(expect(th.type()).to_equal("graph"))
    }

    it "contains type nodes" {
        th = reflect.type_hierarchy()
        assert(expect(th.has_node("type:num")).to_be_truthy())
        assert(expect(th.has_node("type:any")).to_be_truthy())
    }

    it "does not contain scope:main" {
        th = reflect.type_hierarchy()
        result = th.has_node("scope:main")
        assert(expect(result).to_equal(false))
    }

    it "preserves subtype edges" {
        th = reflect.type_hierarchy()
        assert(expect(th.has_path("type:bignum", "type:any")).to_be_truthy())
    }
}

describe "universe module nodes" {
    it "has module node after import" {
        import "math"
        u = reflect.universe()
        assert(expect(u.has_node("module:math")).to_be_truthy())
    }

    it "has import edge after import" {
        import "math"
        u = reflect.universe()
        assert(expect(u.has_path("scope:main", "module:math")).to_be_truthy())
    }
}

describe "graph templates in universe" {
    it "has graph:Name node after declaration" {
        graph Person {
            name: "unnamed"
        }
        u = reflect.universe()
        assert(expect(u.has_node("graph:Person")).to_be_truthy())
    }

    it "graph template is subtype of type:graph" {
        graph Animal {
            name: "unnamed"
        }
        u = reflect.universe()
        assert(expect(u.has_path("graph:Animal", "type:graph")).to_be_truthy())
    }

    it "child graph is subtype of parent" {
        graph Vehicle {
            speed: 0
        }
        graph Car from Vehicle {
            doors: 4
        }
        u = reflect.universe()
        assert(expect(u.has_path("graph:Car", "graph:Vehicle")).to_be_truthy())
    }
}

describe "behaviors via configure" {
    it "applies rule from configure block" {
        graph DAG {
            configure { behaviors: [:no_cycles] }
        }
        assert(expect(DAG.has_rule(:no_cycles)).to_be_truthy())
    }
}

describe "exception type hierarchy" {
    it "has error type nodes in universe" {
        u = reflect.universe()
        assert(expect(u.has_node("error:ValueError")).to_be_truthy())
        assert(expect(u.has_node("error:IOError")).to_be_truthy())
        assert(expect(u.has_node("error:FileError")).to_be_truthy())
    }

    it "FileError is subtype of IOError" {
        u = reflect.universe()
        assert(expect(u.has_path("error:FileError", "error:IOError")).to_be_truthy())
    }

    it "IOError is subtype of type:error" {
        u = reflect.universe()
        assert(expect(u.has_path("error:IOError", "type:error")).to_be_truthy())
    }

    it "ValueError is not subtype of IOError" {
        u = reflect.universe()
        result = u.has_path("error:ValueError", "error:IOError")
        assert(expect(result).to_equal(false))
    }

    it "catch IOError catches FileError" {
        result = "not caught"
        try {
            raise("FileError: test file error")
        } catch IOError as e {
            result = "caught: " + e.type()
        }
        assert(expect(result).to_equal("caught: FileError"))
    }

    it "catch ValueError does not catch IOError" {
        result = "not caught"
        try {
            raise("IOError: test io error")
        } catch ValueError as e {
            result = "caught ValueError"
        } catch as e {
            result = "caught generic"
        }
        assert(expect(result).to_equal("caught generic"))
    }
}

describe "graph.has_node" {
    it "returns true for existing node" {
        g = graph { type: :directed }
        g.add_node("A", 1)
        assert(expect(g.has_node("A")).to_be_truthy())
    }

    it "returns false for missing node" {
        g = graph { type: :directed }
        result = g.has_node("Z")
        assert(expect(result).to_equal(false))
    }
}

describe "instantiated_from edge" {
    it "instance method found via template traversal" {
        graph Person {
            name: "unnamed"
            fn greet() { return "Hi, I'm " + self.name }
        }
        p = Person { name: "Alice" }
        assert(expect(p.greet()).to_equal("Hi, I'm Alice"))
    }

    it "instance property overrides template default" {
        graph Item {
            label: "default"
        }
        item = Item { label: "custom" }
        assert(expect(item.label).to_equal("custom"))
    }

    it "inherited methods work via template traversal" {
        graph Animal {
            name: "unnamed"
            fn speak() { return self.name + " speaks" }
        }
        graph Dog from Animal {
            breed: "unknown"
            fn fetch() { return self.name + " fetches" }
        }
        d = Dog { name: "Rex", breed: "Lab" }
        assert(expect(d.speak()).to_equal("Rex speaks"))
        assert(expect(d.fetch()).to_equal("Rex fetches"))
    }

    it "multiple instances share template" {
        graph Counter {
            count: 0
            fn value() { return self.count }
        }
        a = Counter { count: 10 }
        b = Counter { count: 20 }
        assert(expect(a.value() + b.value()).to_equal(30))
    }

    it ".template() returns template graph" {
        graph Shape {
            sides: 0
        }
        s = Shape { sides: 4 }
        t = s.template()
        assert(expect(typeof(t)).to_equal("graph"))
        assert(expect(t.sides).to_equal(0))
    }

    it ".template() returns none for non-instance" {
        g = graph { type: :directed }
        assert(expect(g.template()).to_equal(none))
    }
}

describe "fn receiver.method() syntax" {
    it "overrides a template method on one instance" {
        graph Greeter {
            name: "unnamed"
            fn greet() { return "Hello from " + self.name }
        }
        p = Greeter { name: "Alice" }
        fn p.greet() { return "Custom: " + self.name }
        assert(expect(p.greet()).to_equal("Custom: Alice"))
    }

    it "does not affect other instances" {
        graph Greeter {
            name: "unnamed"
            fn greet() { return "Hello from " + self.name }
        }
        a = Greeter { name: "Alice" }
        b = Greeter { name: "Bob" }
        fn a.greet() { return "Custom: " + self.name }
        assert(expect(a.greet()).to_equal("Custom: Alice"))
        assert(expect(b.greet()).to_equal("Hello from Bob"))
    }

    it "adds a new method not on template" {
        graph Shape {
            sides: 0
        }
        s = Shape { sides: 4 }
        fn s.describe() { return "I have " + self.sides.to_string() + " sides" }
        assert(expect(s.describe()).to_equal("I have 4 sides"))
    }

    it "works on plain graphs too" {
        g = graph { type: :directed }
        fn g.hello() { return "hi" }
        assert(expect(g.hello()).to_equal("hi"))
    }
}
