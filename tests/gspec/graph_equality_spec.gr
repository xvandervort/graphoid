# graph_equality_spec.gr - Tests that graph equality compares DATA only, not metadata
#
# Run with: gr spec tests/gspec/graph_equality_spec.gr

describe("Graph Equality", () => {

    describe("lists with behaviors", () => {
        it("compares equal when values match despite different rules", () => {
            a = [1, 2, 3]
            b = [1, 2, 3].add_rule(:none_to_zero)
            assert(expect(a == b).to_equal(true))
        })

        it("compares equal after transformation produces same values", () => {
            result = [1, none, 3].add_rule(:none_to_zero)
            expected = [1, 0, 3]
            assert(expect(result == expected).to_equal(true))
        })

        it("compares not equal when values differ", () => {
            a = [1, 2, 3]
            b = [1, 2, 4]
            assert(expect(a == b).to_equal(false))
        })

        it("compares equal with multiple rules attached", () => {
            a = [1, 2, 3]
            b = [1, 2, 3].add_rule(:none_to_zero).add_rule(:positive)
            assert(expect(a == b).to_equal(true))
        })
    })

    describe("graphs with rules", () => {
        it("compares equal when nodes match despite different rulesets", () => {
            g1 = graph { type: :directed }
            g1.add_node("a", 1)
            g1.add_node("b", 2)

            g2 = graph { type: :directed }
            g2.add_node("a", 1)
            g2.add_node("b", 2)

            assert(expect(g1 == g2).to_equal(true))
        })

        it("compares not equal when nodes differ", () => {
            g1 = graph { type: :directed }
            g1.add_node("a", 1)

            g2 = graph { type: :directed }
            g2.add_node("a", 2)

            assert(expect(g1 == g2).to_equal(false))
        })

        it("compares not equal when graph types differ", () => {
            g1 = graph { type: :directed }
            g1.add_node("a", 1)

            g2 = graph { type: :undirected }
            g2.add_node("a", 1)

            assert(expect(g1 == g2).to_equal(false))
        })
    })

    describe("empty collections", () => {
        it("empty lists compare equal", () => {
            assert(expect([] == []).to_equal(true))
        })

        it("empty list with rule equals empty list without", () => {
            a = []
            b = [].add_rule(:none_to_zero)
            assert(expect(a == b).to_equal(true))
        })
    })

    describe("equals method with include: option", () => {
        it("returns true when data and rules match", () => {
            g1 = graph { type: :directed }
            g1.add_node("a", 1)
            g1.add_rule(:no_duplicates)

            g2 = graph { type: :directed }
            g2.add_node("a", 1)
            g2.add_rule(:no_duplicates)

            assert(expect(g1.equals(g2, {include: :rules})).to_equal(true))
        })

        it("returns false when data matches but rules differ", () => {
            g1 = graph { type: :directed }
            g1.add_node("a", 1)
            g1.add_rule(:no_duplicates)

            g2 = graph { type: :directed }
            g2.add_node("a", 1)
            g2.add_rule(:positive)

            assert(expect(g1.equals(g2, {include: :rules})).to_equal(false))
        })

        it("returns true when data and rulesets match", () => {
            g1 = graph { type: :directed, ruleset: :dag }
            g1.add_node("a", 1)

            g2 = graph { type: :directed, ruleset: :dag }
            g2.add_node("a", 1)

            assert(expect(g1.equals(g2, {include: :rulesets})).to_equal(true))
        })

        it("returns false when data matches but rulesets differ", () => {
            g1 = graph { type: :directed, ruleset: :dag }
            g1.add_node("a", 1)

            g2 = graph { type: :directed, ruleset: :tree }
            g2.add_node("a", 1)

            assert(expect(g1.equals(g2, {include: :rulesets})).to_equal(false))
        })

        it("supports multiple layers with list syntax", () => {
            g1 = graph { type: :directed, ruleset: :dag }
            g1.add_node("a", 1)
            g1.add_rule(:no_duplicates)

            g2 = graph { type: :directed, ruleset: :dag }
            g2.add_node("a", 1)
            g2.add_rule(:no_duplicates)

            assert(expect(g1.equals(g2, {include: [:rules, :rulesets]})).to_equal(true))
        })
    })

    describe("equals method with only: option", () => {
        it("compares only rules, ignoring data differences", () => {
            g1 = graph { type: :directed }
            g1.add_node("a", 1)
            g1.add_rule(:no_duplicates)

            g2 = graph { type: :directed }
            g2.add_node("b", 999)  # Different data!
            g2.add_rule(:no_duplicates)

            assert(expect(g1.equals(g2, {only: :rules})).to_equal(true))
        })

        it("returns false when compared layer differs", () => {
            g1 = graph { type: :directed }
            g1.add_node("a", 1)
            g1.add_rule(:no_duplicates)

            g2 = graph { type: :directed }
            g2.add_node("a", 1)
            g2.add_rule(:positive)

            assert(expect(g1.equals(g2, {only: :rules})).to_equal(false))
        })

        it("compares only rulesets, ignoring data and rules", () => {
            g1 = graph { type: :directed, ruleset: :dag }
            g1.add_node("x", 100)
            g1.add_rule(:no_duplicates)

            g2 = graph { type: :directed, ruleset: :dag }
            g2.add_node("y", 200)  # Different data
            g2.add_rule(:positive)  # Different rule

            assert(expect(g1.equals(g2, {only: :rulesets})).to_equal(true))
        })

        it("compares only data when specified", () => {
            g1 = graph { type: :directed, ruleset: :dag }
            g1.add_node("a", 1)
            g1.add_rule(:no_duplicates)

            g2 = graph { type: :directed, ruleset: :tree }  # Different ruleset
            g2.add_node("a", 1)
            g2.add_rule(:positive)  # Different rule

            assert(expect(g1.equals(g2, {only: :data})).to_equal(true))
        })
    })

    describe("equals method with :all option", () => {
        it("returns true when all layers match", () => {
            g1 = graph { type: :directed, ruleset: :dag }
            g1.add_node("a", 1)
            g1.add_rule(:no_duplicates)

            g2 = graph { type: :directed, ruleset: :dag }
            g2.add_node("a", 1)
            g2.add_rule(:no_duplicates)

            assert(expect(g1.equals(g2, {include: :all})).to_equal(true))
        })

        it("returns false when any layer differs", () => {
            g1 = graph { type: :directed, ruleset: :dag }
            g1.add_node("a", 1)
            g1.add_rule(:no_duplicates)

            g2 = graph { type: :directed, ruleset: :dag }
            g2.add_node("a", 1)
            g2.add_rule(:positive)  # Different rule

            assert(expect(g1.equals(g2, {include: :all})).to_equal(false))
        })
    })

    describe("equals method default behavior", () => {
        it("compares data only by default (same as ==)", () => {
            g1 = graph { type: :directed }
            g1.add_node("a", 1)
            g1.add_rule(:no_duplicates)

            g2 = graph { type: :directed }
            g2.add_node("a", 1)
            g2.add_rule(:positive)  # Different rule

            # Without options, equals() should behave like == (data only)
            assert(expect(g1.equals(g2)).to_equal(true))
        })
    })
})
