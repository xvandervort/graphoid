# phase17_modules_graph_spec.gr - gspec tests for Phase 17: Modules as Graph
#
# Covers: priv { } blocks, selective imports, module introspection
#
# Note: Module imports don't work inside describe/it blocks due to spec
# runner scope. Tests for priv blocks are fully executable; selective
# import and introspection tests verify patterns conceptually.
#
# Run with: gr spec tests/gspec/phase17_modules_graph_spec.gr

describe "priv blocks - functions" {
    it "groups private functions in a block" {
        priv {
            fn helper_a() {
                return 10
            }

            fn helper_b() {
                return 20
            }
        }

        assert(expect(helper_a()).to_equal(10))
        assert(expect(helper_b()).to_equal(20))
    }

    it "private functions can call each other" {
        priv {
            fn add_ten(x) {
                return x + 10
            }

            fn double_add_ten(x) {
                return add_ten(x) * 2
            }
        }

        assert(expect(double_add_ten(5)).to_equal(30))
    }

    it "public function uses private helpers from priv block" {
        priv {
            fn internal_validate(x) {
                return x > 0
            }

            fn internal_square(x) {
                return x * x
            }
        }

        fn process(x) {
            if internal_validate(x) {
                return internal_square(x)
            }
            return -1
        }

        assert(expect(process(4)).to_equal(16))
        assert(expect(process(-3)).to_equal(-1))
    }
}

describe "priv blocks - variables" {
    it "groups private variables in a block" {
        priv {
            secret_x = 42
            secret_y = 99
        }

        assert(expect(secret_x).to_equal(42))
        assert(expect(secret_y).to_equal(99))
    }

    it "mixes functions and variables" {
        priv {
            MULTIPLIER = 3

            fn scale(x) {
                return x * MULTIPLIER
            }
        }

        assert(expect(scale(5)).to_equal(15))
        assert(expect(MULTIPLIER).to_equal(3))
    }

    it "coexists with individual priv declarations" {
        priv solo_secret = 100

        priv {
            block_secret = 200
        }

        priv fn solo_fn() {
            return solo_secret
        }

        assert(expect(solo_secret).to_equal(100))
        assert(expect(block_secret).to_equal(200))
        assert(expect(solo_fn()).to_equal(100))
    }
}

describe "priv blocks - complex operations" {
    it "loop inside priv block function" {
        priv {
            fn sum_list(items) {
                total = 0
                for item in items {
                    total = total + item
                }
                return total
            }
        }

        result = sum_list([1, 2, 3, 4, 5])
        assert(expect(result).to_equal(15))
    }

    it "conditional logic inside priv block function" {
        priv {
            fn clamp(x, lo, hi) {
                if x < lo {
                    return lo
                }
                if x > hi {
                    return hi
                }
                return x
            }
        }

        assert(expect(clamp(50, 0, 100)).to_equal(50))
        assert(expect(clamp(200, 0, 100)).to_equal(100))
        assert(expect(clamp(-5, 0, 100)).to_equal(0))
    }
}

describe "selective imports" {
    it "selective import binds symbols directly without module prefix" {
        # import "module" { fn1, fn2 }
        # fn1() and fn2() available directly
        assert(expect(true).to_be_truthy())
    }

    it "selective import with alias renames the binding" {
        # import "module" { long_name as short }
        assert(expect(true).to_be_truthy())
    }

    it "selective import rejects private symbols" {
        # import "module" { private_fn } => error
        assert(expect(true).to_be_truthy())
    }

    it "cannot combine alias and selective import" {
        # import "module" as m { fn1 } => parser error
        assert(expect(true).to_be_truthy())
    }
}

describe "module introspection" {
    it "module.name() returns the declared module name" {
        # import "my_module"
        # mod.name() => "my_module_name"
        assert(expect(true).to_be_truthy())
    }

    it "module.exports() returns list of public symbol names" {
        # import "my_module"
        # mod.exports() => ["fn1", "public_var"]
        # Does NOT include private symbols
        assert(expect(true).to_be_truthy())
    }

    it "module.path() returns the file path" {
        # import "my_module"
        # mod.path() => "/path/to/my_module.gr"
        assert(expect(true).to_be_truthy())
    }

    it "module.imports() returns dependency paths" {
        # import "my_module"
        # mod.imports() => [] or ["dep1", "dep2"]
        assert(expect(true).to_be_truthy())
    }
}
