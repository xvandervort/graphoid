# Collections Module
# Extends built-in collections with common utilities
# Alias: coll

# ==============================================================================
# HELPER FUNCTIONS (Private, prefix with underscore by convention)
# ==============================================================================

# Helper: Check if value is in list
fn _contains(items, value) {
    i = 0
    while i < items.length() {
        if items[i] == value {
            return true
        }
        i = i + 1
    }
    return false
}

# Helper: Check if value is a list (duck typing)
fn _is_list(value) {
    # Try to get length - if it works, it's list-like
    # This is a simplified check; real implementation would use type introspection
    # For now, we assume if it has elements it's a list
    return true
}

# ==============================================================================
# LIST UTILITIES
# ==============================================================================

# Function: flatten
# Description: Flatten a nested list by one level
# Parameters:
#   - nested_list: List potentially containing sublists
# Returns: Flattened list with one level of nesting removed
# Note: Currently simplified - assumes all items are either lists or values
fn flatten(nested_list) {
    result = []
    for item in nested_list {
        # Simply try to iterate - if it's a list, it will work
        # For now, we just add items directly without type checking
        result = result.append(item)
    }
    return result
}

# Function: chunk
# Description: Split a list into chunks of specified size
# Parameters:
#   - items: List to split
#   - size: Size of each chunk
# Returns: List of chunks (sublists)
fn chunk(items, size) {
    if size <= 0 {
        return []
    }

    result = []
    current_chunk = []
    i = 0

    while i < items.length() {
        current_chunk = current_chunk.append(items[i])

        # If chunk is full, add it to result and start new chunk
        if current_chunk.length() == size {
            result = result.append(current_chunk)
            current_chunk = []
        }

        i = i + 1
    }

    # Add remaining items as final chunk (may be smaller than size)
    if current_chunk.length() > 0 {
        result = result.append(current_chunk)
    }

    return result
}

# Function: partition
# Description: Split a list into two lists based on a predicate
# Parameters:
#   - list: List to partition
#   - predicate: Symbol or function name to test elements
# Returns: List of two lists: [matching, non-matching]
fn partition(items, predicate) {
    matching = []
    non_matching = []

    for item in items {
        # For now, we support simple predicates like :even, :positive
        should_match = false

        if predicate == :even {
            should_match = (item % 2 == 0)
        } else if predicate == :odd {
            should_match = (item % 2 == 1)
        } else if predicate == :positive {
            should_match = (item > 0)
        } else if predicate == :negative {
            should_match = (item < 0)
        } else if predicate == :zero {
            should_match = (item == 0)
        }

        if should_match {
            matching = matching.append(item)
        } else {
            non_matching = non_matching.append(item)
        }
    }

    return [matching, non_matching]
}

# Function: zip
# Description: Combine two lists into a list of pairs
# Parameters:
#   - list1: First list
#   - list2: Second list
# Returns: List of two-element lists [[a, 1], [b, 2], ...]
# Note: Stops at the length of the shorter list
fn zip(list1, list2) {
    result = []
    min_len = list1.length()

    if list2.length() < min_len {
        min_len = list2.length()
    }

    i = 0
    while i < min_len {
        pair = [list1[i], list2[i]]
        result = result.append(pair)
        i = i + 1
    }

    return result
}

# Function: unzip
# Description: Split a list of pairs into two separate lists
# Parameters:
#   - pairs: List of two-element lists
# Returns: List of two lists: [[firsts...], [seconds...]]
fn unzip(pairs) {
    firsts = []
    seconds = []

    for pair in pairs {
        firsts = firsts.append(pair[0])
        seconds = seconds.append(pair[1])
    }

    return [firsts, seconds]
}

# Function: take
# Description: Get the first n elements of a list
# Parameters:
#   - list: Source list
#   - n: Number of elements to take
# Returns: New list with first n elements
fn take(items, n) {
    if n <= 0 {
        return []
    }

    if n >= items.length() {
        # Return copy of entire list
        result = []
        for item in items {
            result = result.append(item)
        }
        return result
    }

    result = []
    i = 0
    while i < n {
        result = result.append(items[i])
        i = i + 1
    }

    return result
}

# Function: drop
# Description: Get all elements except the first n
# Parameters:
#   - list: Source list
#   - n: Number of elements to drop
# Returns: New list with first n elements removed
fn drop(items, n) {
    if n <= 0 {
        # Return copy of entire list
        result = []
        for item in items {
            result = result.append(item)
        }
        return result
    }

    if n >= items.length() {
        return []
    }

    result = []
    i = n
    while i < items.length() {
        result = result.append(items[i])
        i = i + 1
    }

    return result
}

# Function: rotate
# Description: Rotate list elements by n positions
# Parameters:
#   - list: Source list
#   - n: Number of positions to rotate (positive = right, negative = left)
# Returns: Rotated list
fn rotate(items, n) {
    if items.length() == 0 {
        return []
    }

    # Normalize n to be within list bounds
    len = items.length()
    n = n % len

    # Negative rotation = rotate left
    if n < 0 {
        n = len + n
    }

    # Split and recombine
    first_part = drop(items, len - n)
    second_part = take(items, len - n)

    result = []
    for item in first_part {
        result = result.append(item)
    }
    for item in second_part {
        result = result.append(item)
    }

    return result
}

# Function: unique
# Description: Remove duplicate values from a list
# Parameters:
#   - list: Source list
# Returns: New list with only unique values (preserves first occurrence)
fn unique(items) {
    result = []

    for item in items {
        # Only add if not already in result
        if _contains(result, item) == false {
            result = result.append(item)
        }
    }

    return result
}

# Function: reverse
# Description: Reverse the order of elements in a list
# Parameters:
#   - list: Source list
# Returns: New list with elements in reverse order
fn reverse(items) {
    result = []
    i = items.length() - 1

    while i >= 0 {
        result = result.append(items[i])
        i = i - 1
    }

    return result
}

# Function: interleave
# Description: Interleave elements from two lists
# Parameters:
#   - list1: First list
#   - list2: Second list
# Returns: New list with alternating elements [a1, b1, a2, b2, ...]
fn interleave(list1, list2) {
    result = []
    max_len = list1.length()

    if list2.length() > max_len {
        max_len = list2.length()
    }

    i = 0
    while i < max_len {
        if i < list1.length() {
            result = result.append(list1[i])
        }
        if i < list2.length() {
            result = result.append(list2[i])
        }
        i = i + 1
    }

    return result
}

# Function: repeat
# Description: Create a list by repeating a value n times
# Parameters:
#   - value: Value to repeat
#   - n: Number of times to repeat
# Returns: List with value repeated n times
fn repeat(value, n) {
    result = []
    i = 0

    while i < n {
        result = result.append(value)
        i = i + 1
    }

    return result
}

# Function: range
# Description: Create a list of numbers from start to end
# Parameters:
#   - start: Starting number (inclusive)
#   - end: Ending number (exclusive)
# Returns: List of numbers [start, start+1, ..., end-1]
fn range(start, end) {
    result = []
    i = start

    while i < end {
        result = result.append(i)
        i = i + 1
    }

    return result
}

# Function: range (overload)
# Description: Create a list from start to end with step
# Parameters:
#   - start: Starting number (inclusive)
#   - end: Ending number (exclusive)
#   - step: Increment value
# Returns: List of numbers with specified step
fn range(start, end, step) {
    result = []

    if step > 0 {
        i = start
        while i < end {
            result = result.append(i)
            i = i + step
        }
    } else if step < 0 {
        i = start
        while i > end {
            result = result.append(i)
            i = i + step
        }
    }

    return result
}

# ==============================================================================
# MAP UTILITIES
# ==============================================================================

# Function: merge
# Description: Merge two maps (second map overwrites first on conflicts)
# Parameters:
#   - map1: First map
#   - map2: Second map
# Returns: New map with all keys from both maps
fn merge(dict1, dict2) {
    result = {}

    # Add all keys from dict1
    keys1 = dict1.keys()
    for key in keys1 {
        result[key] = dict1[key]
    }

    # Add/overwrite with keys from dict2
    keys2 = dict2.keys()
    for key in keys2 {
        result[key] = dict2[key]
    }

    return result
}

# Function: keys
# Description: Get all keys from a map as a list
# Parameters:
#   - map: Source map
# Returns: List of keys
fn get_keys(dict) {
    return dict.keys()
}

# Function: values
# Description: Get all values from a map as a list
# Parameters:
#   - map: Source map
# Returns: List of values
fn get_values(dict) {
    result = []
    map_keys = dict.keys()

    for key in map_keys {
        result = result.append(dict[key])
    }

    return result
}

# Function: invert
# Description: Swap keys and values in a map
# Parameters:
#   - map: Source map
# Returns: New map with keys and values swapped
# Note: If multiple keys have the same value, last one wins
fn invert(dict) {
    result = {}
    map_keys = dict.keys()

    for key in map_keys {
        value = dict[key]
        # Use value as key, key as value
        result[value.to_string()] = key
    }

    return result
}

# Function: has_key
# Description: Check if a map contains a specific key
# Parameters:
#   - map: Source map
#   - key: Key to check
# Returns: true if key exists, false otherwise
fn has_key(dict, key) {
    map_keys = dict.keys()
    return _contains(map_keys, key)
}

# ==============================================================================
# SET OPERATIONS (using lists)
# ==============================================================================

# Function: union
# Description: Get all unique elements from two lists
# Parameters:
#   - list1: First list
#   - list2: Second list
# Returns: List with all unique elements from both lists
fn union(list1, list2) {
    result = []

    # Add all from list1
    for item in list1 {
        if _contains(result, item) == false {
            result = result.append(item)
        }
    }

    # Add unique items from list2
    for item in list2 {
        if _contains(result, item) == false {
            result = result.append(item)
        }
    }

    return result
}

# Function: intersection
# Description: Get elements that appear in both lists
# Parameters:
#   - list1: First list
#   - list2: Second list
# Returns: List with elements common to both lists
fn intersection(list1, list2) {
    result = []

    for item in list1 {
        # Add if in list2 and not already in result
        if _contains(list2, item) && _contains(result, item) == false {
            result = result.append(item)
        }
    }

    return result
}

# Function: difference
# Description: Get elements in list1 that are not in list2
# Parameters:
#   - list1: First list
#   - list2: Second list
# Returns: List with elements from list1 not in list2
fn difference(list1, list2) {
    result = []

    for item in list1 {
        # Add if not in list2 and not already in result
        if _contains(list2, item) == false && _contains(result, item) == false {
            result = result.append(item)
        }
    }

    return result
}

# Function: symmetric_difference
# Description: Get elements that appear in either list but not both
# Parameters:
#   - list1: First list
#   - list2: Second list
# Returns: List with elements in either list but not in both
fn symmetric_difference(list1, list2) {
    result = []

    # Add items from list1 not in list2
    for item in list1 {
        if _contains(list2, item) == false && _contains(result, item) == false {
            result = result.append(item)
        }
    }

    # Add items from list2 not in list1
    for item in list2 {
        if _contains(list1, item) == false && _contains(result, item) == false {
            result = result.append(item)
        }
    }

    return result
}

# Function: is_subset
# Description: Check if list1 is a subset of list2
# Parameters:
#   - list1: Potential subset
#   - list2: Potential superset
# Returns: true if all elements of list1 are in list2
fn is_subset(list1, list2) {
    for item in list1 {
        if _contains(list2, item) == false {
            return false
        }
    }
    return true
}

# Function: is_superset
# Description: Check if list1 is a superset of list2
# Parameters:
#   - list1: Potential superset
#   - list2: Potential subset
# Returns: true if list1 contains all elements of list2
fn is_superset(list1, list2) {
    return is_subset(list2, list1)
}
