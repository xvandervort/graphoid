# JSON Module - JSON parsing and serialization
# Built on io module for file operations
#
# Functions:
# - parse(text) -> value - Parse JSON string to Graphoid value
# - stringify(value) -> string - Convert Graphoid value to JSON string
# - read_json(path) -> value - Read and parse JSON file
# - write_json(path, value) -> bool - Write value to JSON file

import "io"

# Helper: Skip whitespace
fn skip_whitespace(text, pos) {
    size = text.size()

    while pos < size {
        char = text[pos]
        if char == " " {
            pos = pos + 1
        } else {
            if char == "\t" {
                pos = pos + 1
            } else {
                if char == "\n" {
                    pos = pos + 1
                } else {
                    if char == "\r" {
                        pos = pos + 1
                    } else {
                        return pos
                    }
                }
            }
        }
    }

    return pos
}

# Helper: Parse string literal
fn parse_string(text, pos) {
    # pos should be at opening quote
    pos = pos + 1  # Skip opening quote
    result = ""
    size = text.size()

    while pos < size {
        char = text[pos]

        if char == "\"" {
            # End of string
            return [result, pos + 1]
        }

        if char == "\\" {
            # Escape sequence
            pos = pos + 1
            if pos >= size {
                return ["", 0 - 1]  # Error: unexpected end
            }

            escape_char = text[pos]
            if escape_char == "n" {
                result = result + "\n"
            } else {
                if escape_char == "t" {
                    result = result + "\t"
                } else {
                    if escape_char == "r" {
                        result = result + "\r"
                    } else {
                        if escape_char == "\"" {
                            result = result + "\""
                        } else {
                            if escape_char == "\\" {
                                result = result + "\\"
                            } else {
                                # Unknown escape, treat as literal
                                result = result + escape_char
                            }
                        }
                    }
                }
            }
        } else {
            result = result + char
        }

        pos = pos + 1
    }

    return ["", 0 - 1]  # Error: unclosed string
}

# Helper: Parse number
fn parse_number(text, pos) {
    result = ""
    size = text.size()

    while pos < size {
        char = text[pos]

        # Check if char is digit, minus, plus, period, or e/E
        is_num_char = false
        if char == "0" { is_num_char = true }
        if char == "1" { is_num_char = true }
        if char == "2" { is_num_char = true }
        if char == "3" { is_num_char = true }
        if char == "4" { is_num_char = true }
        if char == "5" { is_num_char = true }
        if char == "6" { is_num_char = true }
        if char == "7" { is_num_char = true }
        if char == "8" { is_num_char = true }
        if char == "9" { is_num_char = true }
        if char == "-" { is_num_char = true }
        if char == "+" { is_num_char = true }
        if char == "." { is_num_char = true }
        if char == "e" { is_num_char = true }
        if char == "E" { is_num_char = true }

        if is_num_char {
            result = result + char
            pos = pos + 1
        } else {
            # End of number
            # Convert string to number (simplified - just return as string for now)
            # TODO: Need string-to-number conversion
            return [result, pos]
        }
    }

    return [result, pos]
}

# Main parse function - returns [value, new_position]
fn parse_value(text, pos) {
    pos = skip_whitespace(text, pos)
    size = text.size()

    if pos >= size {
        return [none, 0 - 1]
    }

    char = text[pos]

    # String
    if char == "\"" {
        return parse_string(text, pos)
    }

    # Array
    if char == "[" {
        items = []
        pos = pos + 1  # Skip [

        # Empty array?
        pos = skip_whitespace(text, pos)
        if pos < size {
            if text[pos] == "]" {
                return [items, pos + 1]
            }
        }

        # Parse items
        while pos < size {
            result = parse_value(text, pos)
            value = result[0]
            pos = result[1]

            if pos < 0 {
                return [none, 0 - 1]
            }

            items = items.append(value)

            pos = skip_whitespace(text, pos)

            if pos >= size {
                return [none, 0 - 1]
            }

            next_char = text[pos]
            if next_char == "]" {
                return [items, pos + 1]
            }

            if next_char == "," {
                pos = pos + 1  # Skip comma
            } else {
                return [none, 0 - 1]  # Error
            }
        }

        return [none, 0 - 1]
    }

    # Object
    if char == "{" {
        obj = {}
        pos = pos + 1  # Skip {

        # Empty object?
        pos = skip_whitespace(text, pos)
        if pos < size {
            if text[pos] == "}" {
                return [obj, pos + 1]
            }
        }

        # Parse key-value pairs
        while pos < size {
            pos = skip_whitespace(text, pos)

            # Parse key (must be string)
            if text[pos] != "\"" {
                return [none, 0 - 1]
            }

            key_result = parse_string(text, pos)
            key = key_result[0]
            pos = key_result[1]

            if pos < 0 {
                return [none, 0 - 1]
            }

            pos = skip_whitespace(text, pos)

            # Expect colon
            if pos >= size {
                return [none, 0 - 1]
            }
            if text[pos] != ":" {
                return [none, 0 - 1]
            }
            pos = pos + 1

            # Parse value
            value_result = parse_value(text, pos)
            value = value_result[0]
            pos = value_result[1]

            if pos < 0 {
                return [none, 0 - 1]
            }

            # Add to object (simplified - treat as string key)
            # TODO: Need proper map/hash implementation
            obj[key] = value

            pos = skip_whitespace(text, pos)

            if pos >= size {
                return [none, 0 - 1]
            }

            next_char = text[pos]
            if next_char == "}" {
                return [obj, pos + 1]
            }

            if next_char == "," {
                pos = pos + 1
            } else {
                return [none, 0 - 1]
            }
        }

        return [none, 0 - 1]
    }

    # Boolean true
    if char == "t" {
        if pos + 4 <= size {
            if text[pos + 1] == "r" {
                if text[pos + 2] == "u" {
                    if text[pos + 3] == "e" {
                        return [true, pos + 4]
                    }
                }
            }
        }
        return [none, 0 - 1]
    }

    # Boolean false
    if char == "f" {
        if pos + 5 <= size {
            if text[pos + 1] == "a" {
                if text[pos + 2] == "l" {
                    if text[pos + 3] == "s" {
                        if text[pos + 4] == "e" {
                            return [false, pos + 5]
                        }
                    }
                }
            }
        }
        return [none, 0 - 1]
    }

    # Null
    if char == "n" {
        if pos + 4 <= size {
            if text[pos + 1] == "u" {
                if text[pos + 2] == "l" {
                    if text[pos + 3] == "l" {
                        return [none, pos + 4]
                    }
                }
            }
        }
        return [none, 0 - 1]
    }

    # Number
    return parse_number(text, pos)
}

# Parse JSON text
fn parse(text) {
    result = parse_value(text, 0)
    return result[0]
}

# Stringify value to JSON
fn stringify(value) {
    # TODO: Implement JSON serialization
    # For now, return simple string representation
    return value + ""
}

# Read JSON file
fn read_json(path) {
    text = io.read_file(path)
    return parse(text)
}

# Write JSON file
fn write_json(path, value) {
    text = stringify(value)
    return io.write_file(path, text)
}
