# HTTP Module - HTTP/HTTPS client and server implementation
# Built on net module for TCP sockets and tls module for HTTPS
#
# Client Functions:
# - get(url) -> response - Perform HTTP/HTTPS GET request
# - post(url, body, content_type) -> response - Perform HTTP/HTTPS POST request
# - parse_url(url) -> {host, port, path, is_https} - Parse URL into components
# - parse_response(response_text) -> {status, headers, body} - Parse HTTP response
#
# Server Functions:
# - create_server(host, port) -> server map
# - add_route(server, method, path, handler) -> updated server map
# - serve(server) - Start listening and handling requests
# - parse_request(raw) -> {method, path, version, headers, body}
# - response(status, content_type, body) -> HTTP response string
# - json_response(data) -> JSON response string
# - file_response(file_path) -> file content response string
# - status_text(code) -> reason phrase
# - content_type_for(path) -> MIME type
#
# HTTPS is fully supported via the tls module (TLS 1.3 in pure Graphoid)

import "net"
import "tls"
import "json"

# Parse URL into components
# Returns: {host, port, path, is_https}
fn parse_url(url) {
    cleaned = url
    is_https = false
    default_port = 80

    # Check for https:// first (must check before http://)
    if url.size() > 8 {
        if url[0] == "h" {
            if url[1] == "t" {
                if url[2] == "t" {
                    if url[3] == "p" {
                        if url[4] == "s" {
                            if url[5] == ":" {
                                if url[6] == "/" {
                                    if url[7] == "/" {
                                        # Found https://
                                        is_https = true
                                        default_port = 443
                                        cleaned = ""
                                        i = 8
                                        while i < url.size() {
                                            cleaned = cleaned + url[i]
                                            i = i + 1
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    # Check for http:// (only if not already https)
    if is_https == false {
        if url.size() > 7 {
            if url[0] == "h" {
                if url[1] == "t" {
                    if url[2] == "t" {
                        if url[3] == "p" {
                            if url[4] == ":" {
                                if url[5] == "/" {
                                    if url[6] == "/" {
                                        # Found http://
                                        cleaned = ""
                                        i = 7
                                        while i < url.size() {
                                            cleaned = cleaned + url[i]
                                            i = i + 1
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    # Find first slash for path
    path_start = 0 - 1
    i = 0
    while i < cleaned.size() {
        if cleaned[i] == "/" {
            path_start = i
            i = cleaned.size()  # Break
        }
        i = i + 1
    }

    host = ""
    port = default_port
    path = "/"

    if path_start < 0 {
        # No path, entire thing is host:port
        host = cleaned
    } else {
        # Extract host and path
        i = 0
        while i < path_start {
            host = host + cleaned[i]
            i = i + 1
        }

        # Extract path
        path = ""
        i = path_start
        while i < cleaned.size() {
            path = path + cleaned[i]
            i = i + 1
        }
    }

    # Check for port in host
    port_start = 0 - 1
    i = 0
    while i < host.size() {
        if host[i] == ":" {
            port_start = i
            i = host.size()  # Break
        }
        i = i + 1
    }

    if port_start >= 0 {
        # Extract port number
        host_only = ""
        i = 0
        while i < port_start {
            host_only = host_only + host[i]
            i = i + 1
        }

        # Extract port string and convert to number
        port_str = ""
        i = port_start + 1
        while i < host.size() {
            port_str = port_str + host[i]
            i = i + 1
        }

        # Convert port string to number
        port_num = port_str.to_num()
        if port_num != none {
            port = port_num
        }

        host = host_only
    }

    return {
        "host": host,
        "port": port,
        "path": path,
        "is_https": is_https
    }
}

# Decode chunked transfer encoding
fn decode_chunked(body_text) {
    result = ""
    lines = []
    current_line = ""
    i = 0

    # Split into lines
    while i < body_text.size() {
        char = body_text[i]
        if char == "\n" {
            lines = lines.append(current_line)
            current_line = ""
        } else {
            if char != "\r" {
                current_line = current_line + char
            }
        }
        i = i + 1
    }
    if current_line != "" {
        lines = lines.append(current_line)
    }

    # Process chunks: size_in_hex, data, size_in_hex, data, ..., 0
    i = 0
    while i < lines.size() {
        size_line = lines[i]
        # Check for final "0" chunk
        if size_line == "0" {
            break
        }
        if size_line == "" {
            i = i + 1
            continue
        }
        # Next line(s) should be the chunk data
        i = i + 1
        if i < lines.size() {
            result = result + lines[i]
        }
        i = i + 1
    }

    return result
}

# Check if response uses chunked encoding
fn is_chunked(headers_text) {
    # Simple check for "transfer-encoding: chunked" in headers
    lower_text = headers_text.lower()
    i = 0
    while i < lower_text.size() - 20 {
        if lower_text[i] == "t" {
            if lower_text[i+1] == "r" {
                if lower_text[i+2] == "a" {
                    if lower_text[i+3] == "n" {
                        if lower_text[i+4] == "s" {
                            if lower_text[i+5] == "f" {
                                if lower_text[i+6] == "e" {
                                    if lower_text[i+7] == "r" {
                                        # Found "transfer", check for "chunked" nearby
                                        j = i + 8
                                        while j < lower_text.size() - 7 {
                                            if lower_text[j] == "c" {
                                                if lower_text[j+1] == "h" {
                                                    if lower_text[j+2] == "u" {
                                                        if lower_text[j+3] == "n" {
                                                            if lower_text[j+4] == "k" {
                                                                if lower_text[j+5] == "e" {
                                                                    if lower_text[j+6] == "d" {
                                                                        return true
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            j = j + 1
                                            if j > i + 30 {
                                                break
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        i = i + 1
    }
    return false
}

# Parse HTTP response
fn parse_response(response_text) {
    lines = []
    current_line = ""
    i = 0
    size = response_text.size()

    # Split into lines
    while i < size {
        char = response_text[i]

        if char == "\n" {
            lines = lines.append(current_line)
            current_line = ""
        } else {
            if char != "\r" {
                current_line = current_line + char
            }
        }

        i = i + 1
    }

    if current_line != "" {
        lines = lines.append(current_line)
    }

    # Parse status line
    status = 0
    if lines.size() > 0 {
        status_line = lines[0]
        # Extract status code - look for first space, then parse 3-digit code
        space_count = 0
        status_str = ""
        j = 0
        while j < status_line.size() {
            char = status_line[j]
            if char == " " {
                space_count = space_count + 1
            } else {
                if space_count == 1 {
                    # We're in the status code section
                    if status_str.size() < 3 {
                        status_str = status_str + char
                    }
                }
            }
            j = j + 1
        }
        status_num = status_str.to_num()
        if status_num != none {
            status = status_num
        }
    }

    # Find empty line separating headers and body
    body_start = 0 - 1
    headers_text = ""
    i = 0
    while i < lines.size() {
        if lines[i] == "" {
            body_start = i + 1
            i = lines.size()  # Break
        } else {
            headers_text = headers_text + lines[i] + "\n"
        }
        i = i + 1
    }

    # Extract body
    body = ""
    if body_start >= 0 {
        i = body_start
        while i < lines.size() {
            if i > body_start {
                body = body + "\n"
            }
            body = body + lines[i]
            i = i + 1
        }
    }

    # Handle chunked transfer encoding
    if is_chunked(headers_text) {
        body = decode_chunked(body)
    }

    return {
        "status": status,
        "headers": {},
        "body": body
    }
}

# Perform HTTP/HTTPS GET request
fn get(url) {
    parsed = parse_url(url)
    host = parsed["host"]
    port = parsed["port"]
    path = parsed["path"]
    is_https = parsed["is_https"]

    # Connect to server (TLS for HTTPS, plain TCP for HTTP)
    socket = none
    if is_https {
        socket = tls.tls_connect(host, port)
        # Check for TLS connection errors
        if socket["error"] != none {
            return {"status": 0, "headers": "", "body": "", "error": socket["error"]}
        }
        if socket["established"] != true {
            return {"status": 0, "headers": "", "body": "", "error": "TLS handshake failed"}
        }
    } else {
        socket = net.connect(host, port)
    }

    # Build HTTP request
    request = "GET " + path + " HTTP/1.1\r\n"
    request = request + "Host: " + host + "\r\n"
    request = request + "User-Agent: Graphoid/1.0\r\n"
    request = request + "Accept: */*\r\n"
    request = request + "Connection: close\r\n"
    request = request + "\r\n"

    # Send request (use appropriate function based on protocol)
    if is_https {
        tls.tls_send(socket, request)
    } else {
        net.send(socket, request)
    }

    # Receive response
    response = ""
    while true {
        chunk = ""
        if is_https {
            chunk = tls.tls_recv(socket, 4096)
        } else {
            chunk = net.recv(socket, 4096)
        }
        if chunk == "" {
            break
        }
        response = response + chunk
    }

    # Close connection
    if is_https {
        tls.tls_close(socket)
    } else {
        net.close(socket)
    }

    # Parse and return response
    return parse_response(response)
}

# Perform HTTP/HTTPS POST request
fn post(url, body, content_type) {
    parsed = parse_url(url)
    host = parsed["host"]
    port = parsed["port"]
    path = parsed["path"]
    is_https = parsed["is_https"]

    # Connect to server (TLS for HTTPS, plain TCP for HTTP)
    if is_https {
        socket = tls.tls_connect(host, port)
    } else {
        socket = net.connect(host, port)
    }

    # Build HTTP request
    request = "POST " + path + " HTTP/1.1\r\n"
    request = request + "Host: " + host + "\r\n"
    request = request + "User-Agent: Graphoid/1.0\r\n"
    request = request + "Content-Type: " + content_type + "\r\n"
    request = request + "Content-Length: " + body.size().to_string() + "\r\n"
    request = request + "Connection: close\r\n"
    request = request + "\r\n"
    request = request + body

    # Send request (use appropriate function based on protocol)
    if is_https {
        tls.tls_send(socket, request)
    } else {
        net.send(socket, request)
    }

    # Receive response
    response = ""
    while true {
        if is_https {
            chunk = tls.tls_recv(socket, 4096)
        } else {
            chunk = net.recv(socket, 4096)
        }
        if chunk == "" {
            break
        }
        response = response + chunk
    }

    # Close connection
    if is_https {
        tls.tls_close(socket)
    } else {
        net.close(socket)
    }

    # Parse and return response
    return parse_response(response)
}

# ============================================
# Server-side functions (Phase 18.6)
# ============================================

# Map HTTP status codes to reason phrases
fn status_text(code) {
    if code == 200 { return "OK" }
    if code == 201 { return "Created" }
    if code == 204 { return "No Content" }
    if code == 301 { return "Moved Permanently" }
    if code == 302 { return "Found" }
    if code == 304 { return "Not Modified" }
    if code == 400 { return "Bad Request" }
    if code == 401 { return "Unauthorized" }
    if code == 403 { return "Forbidden" }
    if code == 404 { return "Not Found" }
    if code == 405 { return "Method Not Allowed" }
    if code == 500 { return "Internal Server Error" }
    if code == 502 { return "Bad Gateway" }
    if code == 503 { return "Service Unavailable" }
    return "Unknown"
}

# Detect content type from file extension
fn content_type_for(file_path) {
    # Find the last dot
    dot_pos = 0 - 1
    i = 0
    while i < file_path.size() {
        if file_path[i] == "." {
            dot_pos = i
        }
        i = i + 1
    }

    if dot_pos < 0 {
        return "application/octet-stream"
    }

    ext = file_path.substring(dot_pos + 1, file_path.size()).lower()

    if ext == "html" { return "text/html" }
    if ext == "htm" { return "text/html" }
    if ext == "css" { return "text/css" }
    if ext == "js" { return "application/javascript" }
    if ext == "json" { return "application/json" }
    if ext == "txt" { return "text/plain" }
    if ext == "png" { return "image/png" }
    if ext == "jpg" { return "image/jpeg" }
    if ext == "jpeg" { return "image/jpeg" }
    if ext == "gif" { return "image/gif" }
    if ext == "svg" { return "image/svg+xml" }
    if ext == "ico" { return "image/x-icon" }
    if ext == "xml" { return "application/xml" }
    if ext == "pdf" { return "application/pdf" }

    return "application/octet-stream"
}

# Build an HTTP response string
fn response(status_code, content_type, body) {
    reason = status_text(status_code)
    resp = "HTTP/1.1 " + status_code.to_string() + " " + reason + "\r\n"
    resp = resp + "Content-Type: " + content_type + "\r\n"
    resp = resp + "Content-Length: " + body.size().to_string() + "\r\n"
    resp = resp + "Connection: close\r\n"
    resp = resp + "Server: Graphoid/1.0\r\n"
    resp = resp + "\r\n"
    resp = resp + body
    return resp
}

# Build a JSON response
fn json_response(data) {
    body = json.to_string(data)
    return response(200, "application/json", body)
}

# Parse an HTTP request into {method, path, version, headers, body}
fn parse_request(raw_text) {
    # Split by \r\n to get lines
    lines = raw_text.split("\r\n")

    if lines.size() == 0 {
        return {"method": "", "path": "", "version": "", "headers": {}, "body": ""}
    }

    # Parse request line: METHOD PATH VERSION
    request_line = lines[0]
    parts = request_line.split(" ")

    method = ""
    path = ""
    version = ""

    if parts.size() >= 1 { method = parts[0] }
    if parts.size() >= 2 { path = parts[1] }
    if parts.size() >= 3 { version = parts[2] }

    # Parse headers (until empty line)
    headers = {}
    body_start = 0 - 1
    i = 1
    while i < lines.size() {
        line = lines[i]
        if line == "" {
            body_start = i + 1
            i = lines.size()  # break
        } else {
            # Find colon separator
            colon_pos = line.index_of(":")
            if colon_pos > 0 {
                header_name = line.substring(0, colon_pos).lower().trim()
                header_value = line.substring(colon_pos + 1, line.size()).trim()
                headers[header_name] = header_value
            }
        }
        i = i + 1
    }

    # Extract body
    body = ""
    if body_start > 0 {
        i = body_start
        while i < lines.size() {
            if i > body_start {
                body = body + "\r\n"
            }
            body = body + lines[i]
            i = i + 1
        }
    }

    return {
        "method": method,
        "path": path,
        "version": version,
        "headers": headers,
        "body": body
    }
}

# Serve a static file as HTTP response
fn file_response(file_path) {
    import "fs"
    import "io"

    if fs.exists(file_path) == false {
        return response(404, "text/plain", "File not found: " + file_path)
    }

    content = io.read_file(file_path)
    ct = content_type_for(file_path)
    return response(200, ct, content)
}

# Create a simple HTTP server configuration
# Routes are stored flat on the server map as "route:METHOD /path" keys.
# Usage:
#   server = http.create_server("127.0.0.1", 8080)
#   http.add_route(server, "GET", "/", handler_fn)
#   http.serve(server)
fn create_server(host, port) {
    return {
        "host": host,
        "port": port
    }
}

fn add_route(server, method, path, handler) {
    route_key = "route:" + method + " " + path
    server[route_key] = handler
    return server
}

fn serve(server) {
    host = server["host"]
    port = server["port"]

    listener = net.bind(host, port)
    actual_port = net.listener_port(listener)
    print("Server listening on http://" + host + ":" + actual_port.to_string())

    while true {
        try {
            socket = net.accept(listener)

            # Read the request
            raw = net.recv(socket, 8192)

            if raw.size() > 0 {
                req = parse_request(raw)

                # Look up route handler
                route_key = "route:" + req["method"] + " " + req["path"]

                resp = ""
                if server.has_key(route_key) {
                    handler = server[route_key]
                    resp = handler(req)
                } else {
                    resp = response(404, "text/plain", "Not Found: " + req["path"])
                }

                net.send(socket, resp)
            }

            net.close(socket)
        } catch as e {
            print("Server error: " + e.to_string())
        }
    }

    net.close_listener(listener)
}
