# HTTP Module - HTTP/HTTPS client implementation
# Built on net module for TCP sockets and tls module for HTTPS
#
# Functions:
# - get(url) -> response - Perform HTTP/HTTPS GET request
# - post(url, body, content_type) -> response - Perform HTTP/HTTPS POST request
# - parse_url(url) -> {host, port, path, is_https} - Parse URL into components
# - parse_response(response_text) -> {status, headers, body} - Parse HTTP response
#
# HTTPS is fully supported via the tls module (TLS 1.3 in pure Graphoid)

import "net"
import "tls"

# Parse URL into components
# Returns: {host, port, path, is_https}
fn parse_url(url) {
    cleaned = url
    is_https = false
    default_port = 80

    # Check for https:// first (must check before http://)
    if url.size() > 8 {
        if url[0] == "h" {
            if url[1] == "t" {
                if url[2] == "t" {
                    if url[3] == "p" {
                        if url[4] == "s" {
                            if url[5] == ":" {
                                if url[6] == "/" {
                                    if url[7] == "/" {
                                        # Found https://
                                        is_https = true
                                        default_port = 443
                                        cleaned = ""
                                        i = 8
                                        while i < url.size() {
                                            cleaned = cleaned + url[i]
                                            i = i + 1
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    # Check for http:// (only if not already https)
    if is_https == false {
        if url.size() > 7 {
            if url[0] == "h" {
                if url[1] == "t" {
                    if url[2] == "t" {
                        if url[3] == "p" {
                            if url[4] == ":" {
                                if url[5] == "/" {
                                    if url[6] == "/" {
                                        # Found http://
                                        cleaned = ""
                                        i = 7
                                        while i < url.size() {
                                            cleaned = cleaned + url[i]
                                            i = i + 1
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    # Find first slash for path
    path_start = 0 - 1
    i = 0
    while i < cleaned.size() {
        if cleaned[i] == "/" {
            path_start = i
            i = cleaned.size()  # Break
        }
        i = i + 1
    }

    host = ""
    port = default_port
    path = "/"

    if path_start < 0 {
        # No path, entire thing is host:port
        host = cleaned
    } else {
        # Extract host and path
        i = 0
        while i < path_start {
            host = host + cleaned[i]
            i = i + 1
        }

        # Extract path
        path = ""
        i = path_start
        while i < cleaned.size() {
            path = path + cleaned[i]
            i = i + 1
        }
    }

    # Check for port in host
    port_start = 0 - 1
    i = 0
    while i < host.size() {
        if host[i] == ":" {
            port_start = i
            i = host.size()  # Break
        }
        i = i + 1
    }

    if port_start >= 0 {
        # Extract port number
        host_only = ""
        i = 0
        while i < port_start {
            host_only = host_only + host[i]
            i = i + 1
        }

        # Extract port string and convert to number
        port_str = ""
        i = port_start + 1
        while i < host.size() {
            port_str = port_str + host[i]
            i = i + 1
        }

        # Convert port string to number
        port_num = port_str.to_num()
        if port_num != none {
            port = port_num
        }

        host = host_only
    }

    return {
        "host": host,
        "port": port,
        "path": path,
        "is_https": is_https
    }
}

# Decode chunked transfer encoding
fn decode_chunked(body_text) {
    result = ""
    lines = []
    current_line = ""
    i = 0

    # Split into lines
    while i < body_text.size() {
        char = body_text[i]
        if char == "\n" {
            lines = lines.append(current_line)
            current_line = ""
        } else {
            if char != "\r" {
                current_line = current_line + char
            }
        }
        i = i + 1
    }
    if current_line != "" {
        lines = lines.append(current_line)
    }

    # Process chunks: size_in_hex, data, size_in_hex, data, ..., 0
    i = 0
    while i < lines.size() {
        size_line = lines[i]
        # Check for final "0" chunk
        if size_line == "0" {
            break
        }
        if size_line == "" {
            i = i + 1
            continue
        }
        # Next line(s) should be the chunk data
        i = i + 1
        if i < lines.size() {
            result = result + lines[i]
        }
        i = i + 1
    }

    return result
}

# Check if response uses chunked encoding
fn is_chunked(headers_text) {
    # Simple check for "transfer-encoding: chunked" in headers
    lower_text = headers_text.lower()
    i = 0
    while i < lower_text.size() - 20 {
        if lower_text[i] == "t" {
            if lower_text[i+1] == "r" {
                if lower_text[i+2] == "a" {
                    if lower_text[i+3] == "n" {
                        if lower_text[i+4] == "s" {
                            if lower_text[i+5] == "f" {
                                if lower_text[i+6] == "e" {
                                    if lower_text[i+7] == "r" {
                                        # Found "transfer", check for "chunked" nearby
                                        j = i + 8
                                        while j < lower_text.size() - 7 {
                                            if lower_text[j] == "c" {
                                                if lower_text[j+1] == "h" {
                                                    if lower_text[j+2] == "u" {
                                                        if lower_text[j+3] == "n" {
                                                            if lower_text[j+4] == "k" {
                                                                if lower_text[j+5] == "e" {
                                                                    if lower_text[j+6] == "d" {
                                                                        return true
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            j = j + 1
                                            if j > i + 30 {
                                                break
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        i = i + 1
    }
    return false
}

# Parse HTTP response
fn parse_response(response_text) {
    lines = []
    current_line = ""
    i = 0
    size = response_text.size()

    # Split into lines
    while i < size {
        char = response_text[i]

        if char == "\n" {
            lines = lines.append(current_line)
            current_line = ""
        } else {
            if char != "\r" {
                current_line = current_line + char
            }
        }

        i = i + 1
    }

    if current_line != "" {
        lines = lines.append(current_line)
    }

    # Parse status line
    status = 0
    if lines.size() > 0 {
        status_line = lines[0]
        # Extract status code - look for first space, then parse 3-digit code
        space_count = 0
        status_str = ""
        j = 0
        while j < status_line.size() {
            char = status_line[j]
            if char == " " {
                space_count = space_count + 1
            } else {
                if space_count == 1 {
                    # We're in the status code section
                    if status_str.size() < 3 {
                        status_str = status_str + char
                    }
                }
            }
            j = j + 1
        }
        status_num = status_str.to_num()
        if status_num != none {
            status = status_num
        }
    }

    # Find empty line separating headers and body
    body_start = 0 - 1
    headers_text = ""
    i = 0
    while i < lines.size() {
        if lines[i] == "" {
            body_start = i + 1
            i = lines.size()  # Break
        } else {
            headers_text = headers_text + lines[i] + "\n"
        }
        i = i + 1
    }

    # Extract body
    body = ""
    if body_start >= 0 {
        i = body_start
        while i < lines.size() {
            if i > body_start {
                body = body + "\n"
            }
            body = body + lines[i]
            i = i + 1
        }
    }

    # Handle chunked transfer encoding
    if is_chunked(headers_text) {
        body = decode_chunked(body)
    }

    return {
        "status": status,
        "headers": {},
        "body": body
    }
}

# Perform HTTP/HTTPS GET request
fn get(url) {
    parsed = parse_url(url)
    host = parsed["host"]
    port = parsed["port"]
    path = parsed["path"]
    is_https = parsed["is_https"]

    # Connect to server (TLS for HTTPS, plain TCP for HTTP)
    socket = none
    if is_https {
        socket = tls.tls_connect(host, port)
        # Check for TLS connection errors
        if socket["error"] != none {
            return {"status": 0, "headers": "", "body": "", "error": socket["error"]}
        }
        if socket["established"] != true {
            return {"status": 0, "headers": "", "body": "", "error": "TLS handshake failed"}
        }
    } else {
        socket = net.connect(host, port)
    }

    # Build HTTP request
    request = "GET " + path + " HTTP/1.1\r\n"
    request = request + "Host: " + host + "\r\n"
    request = request + "User-Agent: Graphoid/1.0\r\n"
    request = request + "Accept: */*\r\n"
    request = request + "Connection: close\r\n"
    request = request + "\r\n"

    # Send request (use appropriate function based on protocol)
    if is_https {
        tls.tls_send(socket, request)
    } else {
        net.send(socket, request)
    }

    # Receive response
    response = ""
    while true {
        chunk = ""
        if is_https {
            chunk = tls.tls_recv(socket, 4096)
        } else {
            chunk = net.recv(socket, 4096)
        }
        if chunk == "" {
            break
        }
        response = response + chunk
    }

    # Close connection
    if is_https {
        tls.tls_close(socket)
    } else {
        net.close(socket)
    }

    # Parse and return response
    return parse_response(response)
}

# Perform HTTP/HTTPS POST request
fn post(url, body, content_type) {
    parsed = parse_url(url)
    host = parsed["host"]
    port = parsed["port"]
    path = parsed["path"]
    is_https = parsed["is_https"]

    # Connect to server (TLS for HTTPS, plain TCP for HTTP)
    if is_https {
        socket = tls.tls_connect(host, port)
    } else {
        socket = net.connect(host, port)
    }

    # Build HTTP request
    request = "POST " + path + " HTTP/1.1\r\n"
    request = request + "Host: " + host + "\r\n"
    request = request + "User-Agent: Graphoid/1.0\r\n"
    request = request + "Content-Type: " + content_type + "\r\n"
    request = request + "Content-Length: " + body.size().to_string() + "\r\n"
    request = request + "Connection: close\r\n"
    request = request + "\r\n"
    request = request + body

    # Send request (use appropriate function based on protocol)
    if is_https {
        tls.tls_send(socket, request)
    } else {
        net.send(socket, request)
    }

    # Receive response
    response = ""
    while true {
        if is_https {
            chunk = tls.tls_recv(socket, 4096)
        } else {
            chunk = net.recv(socket, 4096)
        }
        if chunk == "" {
            break
        }
        response = response + chunk
    }

    # Close connection
    if is_https {
        tls.tls_close(socket)
    } else {
        net.close(socket)
    }

    # Parse and return response
    return parse_response(response)
}
