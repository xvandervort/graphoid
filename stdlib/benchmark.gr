# Benchmarking Infrastructure for Glang
# Provides performance measurement and comparison tools
#
# NOTE: Due to current language limitations with function parameters,
# this module uses a different approach that works within current constraints

import "time" as Time

# Simple timing measurement
func start_timer() {
    return Time.now()
}

func end_timer(start_time) {
    end_time = Time.now()
    duration = end_time.to_num() - start_time.to_num()
    return {
        "start_time": start_time.to_string(),
        "end_time": end_time.to_string(),
        "duration": duration
    }
}

# Measure operation by name using a dispatch pattern
func measure_operation(operation_name, iterations, test_data) {
    if iterations <= 0 {
        iterations = 1
    }

    start_time = start_timer()

    # Dispatch to specific operations
    for i in [].upto(iterations - 1) {
        if operation_name == "list_append" {
            _benchmark_list_append(test_data)
        } else if operation_name == "list_generate" {
            _benchmark_list_generate(test_data)
        } else if operation_name == "list_map" {
            _benchmark_list_map(test_data)
        } else if operation_name == "list_filter" {
            _benchmark_list_filter(test_data)
        } else {
            print("Unknown operation: " + operation_name)
        }
    }

    timing = end_timer(start_time)
    avg_duration = timing["duration"] / iterations

    return {
        "operation": operation_name,
        "iterations": iterations,
        "total_duration": timing["duration"],
        "average_duration": avg_duration,
        "operations_per_second": iterations / timing["duration"]
    }
}

# Predefined benchmark operations
func _benchmark_list_append(size) {
    items = []
    for i in [].upto(size - 1) {
        items.append(i)
    }
    return items.size()
}

func _benchmark_list_generate(size) {
    nums = []
    result = nums.generate(1, size, 1)
    return result.size()
}

func _benchmark_list_map(size) {
    nums = []
    base = nums.upto(size)
    result = base.map("double")
    return result.size()
}

func _benchmark_list_filter(size) {
    nums = []
    base = nums.upto(size)
    result = base.filter("even")
    return result.size()
}

# Compare multiple operations
func compare_operations(operation_names, iterations, test_size) {
    results = {}

    for name in operation_names {
        timing = measure_operation(name, iterations, test_size)
        results[name] = timing
    }

    return results
}

# Format results for display
func format_results(results) {
    if results.has_key("operation") {
        # Single operation result
        output = "Benchmark Results:\n"
        output = output + "Operation: " + results["operation"] + "\n"
        output = output + "Iterations: " + results["iterations"].to_string() + "\n"
        output = output + "Total Duration: " + results["total_duration"].to_string() + " seconds\n"
        output = output + "Average Duration: " + results["average_duration"].to_string() + " seconds\n"
        output = output + "Operations/Second: " + results["operations_per_second"].to_string()
        return output
    } else {
        # Comparison results - print directly to avoid string concatenation issues
        print("Benchmark Comparison:")
        print("Operation          | Avg Time    | Ops/Sec")
        print("-------------------|-------------|--------")

        for name in results.keys() {
            timing = results[name]
            avg_str = timing["average_duration"].to_string()
            ops_str = timing["operations_per_second"].to_string()
            line = name + " | " + avg_str + "s | " + ops_str
            print(line)
        }
        return "Comparison complete"
    }
}

# Run a benchmark suite
func run_suite(suite_name, operation_names, iterations, test_size) {
    print("=== " + suite_name + " ===")
    results = compare_operations(operation_names, iterations, test_size)
    print(format_results(results))
    return results
}

# Quick performance test
func quick_performance_test() {
    operations = ["list_append", "list_generate", "list_map", "list_filter"]
    return run_suite("Quick Performance Test", operations, 10, 100)
}