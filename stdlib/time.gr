# Time Module - Calendar-aware time operations
# Built on os.system_timestamp() primitive
#
# Time values are Unix timestamps (seconds since 1970-01-01 00:00:00 UTC)
#
# Functions:
# - now() -> timestamp - Current time
# - today() -> timestamp - Start of today (00:00:00 UTC)
# - from_date(year, month, day) -> timestamp - Create from date
# - as_datetime(timestamp, format) -> string - Format as datetime
# - as_date(timestamp, format) -> string - Format as date
# - add_months(timestamp, months) -> timestamp - Calendar-aware month addition
# - is_weekday(timestamp) -> bool - Check if Monday-Friday
# - is_weekend(timestamp) -> bool - Check if Saturday-Sunday
# - start_of_week(timestamp) -> timestamp - Get Monday of week
# - end_of_month(timestamp) -> timestamp - Get last day of month
# - skip_weekends(timestamp) -> timestamp - Skip to next weekday

import "os"

# Constants
SECONDS_PER_DAY = 86400
SECONDS_PER_HOUR = 3600
SECONDS_PER_MINUTE = 60

# Days in each month (non-leap year)
DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

# Get current time
fn now() {
    return os.system_timestamp()
}

# Get start of today (00:00:00 UTC)
fn today() {
    current = os.system_timestamp()
    # Truncate to start of day
    days_since_epoch = (current / SECONDS_PER_DAY).down()
    return days_since_epoch * SECONDS_PER_DAY
}

# Check if year is leap year
fn is_leap_year(year) {
    if year % 400 == 0 {
        return true
    }
    if year % 100 == 0 {
        return false
    }
    if year % 4 == 0 {
        return true
    }
    return false
}

# Get days in month
fn days_in_month_for_year(year, month) {
    days = DAYS_IN_MONTH[month - 1]
    if month == 2 {
        if is_leap_year(year) {
            return 29
        }
    }
    return days
}

# Calculate days since epoch (1970-01-01) for a given date
fn days_since_epoch(year, month, day) {
    # Count leap years from 1970
    leap_years = 0
    y = 1970
    while y < year {
        if is_leap_year(y) {
            leap_years = leap_years + 1
        }
        y = y + 1
    }

    # Regular years
    regular_years = year - 1970 - leap_years
    days = regular_years * 365 + leap_years * 366

    # Add days for months in current year
    m = 1
    while m < month {
        days = days + days_in_month_for_year(year, m)
        m = m + 1
    }

    # Add days in current month
    days = days + day - 1

    return days
}

# Create timestamp from date (year, month, day)
fn from_date(year, month, day) {
    days = days_since_epoch(year, month, day)
    return days * SECONDS_PER_DAY
}

# Extract date components from timestamp
fn timestamp_to_date(timestamp) {
    days = (timestamp / SECONDS_PER_DAY).down()

    # Calculate year
    year = 1970
    remaining_days = days

    while remaining_days > 0 {
        days_in_year = 365
        if is_leap_year(year) {
            days_in_year = 366
        }

        if remaining_days >= days_in_year {
            remaining_days = remaining_days - days_in_year
            year = year + 1
        } else {
            break
        }
    }

    # Calculate month and day
    month = 1
    while month <= 12 {
        days_in_month = days_in_month_for_year(year, month)
        if remaining_days >= days_in_month {
            remaining_days = remaining_days - days_in_month
            month = month + 1
        } else {
            break
        }
    }

    day = remaining_days + 1

    return {"year": year, "month": month, "day": day}
}

# Format timestamp according to format specifier
# format(timestamp, :date) -> "2025-11-14"
# format(timestamp, :datetime) -> "2025-11-14T23:08:53Z"
# format(timestamp, :long) -> "November 14, 2025"
# format(timestamp, none) -> same as :datetime
fn format(timestamp, format_type) {
    date = timestamp_to_date(timestamp)
    year = date["year"]
    month = date["month"]
    day = date["day"]

    # Default to datetime if none
    actual_format = format_type
    if actual_format == none {
        actual_format = :datetime
    }

    # Format year, month, day strings
    year_str = year.to_string()

    month_str = month.to_string()
    if month < 10 {
        month_str = "0" + month_str
    }

    day_str = day.to_string()
    if day < 10 {
        day_str = "0" + day_str
    }

    # Handle :long format
    if actual_format == :long {
        month_names = ["January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"]
        month_name = month_names[month - 1]
        return month_name + " " + day.to_string() + ", " + year.to_string()
    }

    # Handle :date format
    if actual_format == :date {
        return year_str + "-" + month_str + "-" + day_str
    }

    # Handle :datetime format (default)
    # Calculate time of day
    seconds_today = timestamp % SECONDS_PER_DAY
    hours = (seconds_today / SECONDS_PER_HOUR).down()
    remaining = seconds_today % SECONDS_PER_HOUR
    minutes = (remaining / SECONDS_PER_MINUTE).down()
    seconds = (remaining % SECONDS_PER_MINUTE).down()

    # Format time part
    hours_str = hours.to_string()
    if hours < 10 {
        hours_str = "0" + hours_str
    }

    minutes_str = minutes.to_string()
    if minutes < 10 {
        minutes_str = "0" + minutes_str
    }

    seconds_str = seconds.to_string()
    if seconds < 10 {
        seconds_str = "0" + seconds_str
    }

    date_str = year_str + "-" + month_str + "-" + day_str
    return date_str + "T" + hours_str + ":" + minutes_str + ":" + seconds_str + "Z"
}

# Get day of week (0 = Monday, 6 = Sunday)
# 1970-01-01 was a Thursday (day 3)
fn day_of_week(timestamp) {
    days = (timestamp / SECONDS_PER_DAY).down()
    # 1970-01-01 was Thursday (3), so offset by 3
    dow = (days + 3) % 7
    return dow
}

# Check if timestamp is a weekday (Monday-Friday)
fn is_weekday(timestamp) {
    dow = day_of_week(timestamp)
    return dow >= 0 && dow <= 4
}

# Check if timestamp is a weekend (Saturday-Sunday)
fn is_weekend(timestamp) {
    dow = day_of_week(timestamp)
    return dow == 5 || dow == 6
}

# Get start of week (Monday) for given timestamp
fn start_of_week(timestamp) {
    # Truncate to start of day
    days = (timestamp / SECONDS_PER_DAY).down()
    day_start = days * SECONDS_PER_DAY

    # Get day of week
    dow = day_of_week(day_start)

    # Subtract days to get to Monday (0)
    days_to_subtract = dow
    return day_start - (days_to_subtract * SECONDS_PER_DAY)
}

# Get end of month for given timestamp
fn end_of_month(timestamp) {
    date = timestamp_to_date(timestamp)
    year = date["year"]
    month = date["month"]

    # Get last day of month
    last_day = days_in_month_for_year(year, month)

    # Create timestamp for last day of month
    return from_date(year, month, last_day)
}

# Add months to timestamp (calendar-aware)
fn add_months(timestamp, months_to_add) {
    date = timestamp_to_date(timestamp)
    year = date["year"]
    month = date["month"]
    day = date["day"]

    # Add months
    new_month = month + months_to_add

    # Handle year overflow
    while new_month > 12 {
        new_month = new_month - 12
        year = year + 1
    }

    while new_month < 1 {
        new_month = new_month + 12
        year = year - 1
    }

    # Clamp day to valid range for new month
    max_day = days_in_month_for_year(year, new_month)
    if day > max_day {
        day = max_day
    }

    return from_date(year, new_month, day)
}

# Skip weekends - if timestamp is on weekend, move to next Monday
fn skip_weekends(timestamp) {
    # Truncate to start of day
    days = (timestamp / SECONDS_PER_DAY).down()
    day_start = days * SECONDS_PER_DAY

    dow = day_of_week(day_start)

    # If Saturday (5), add 2 days to Monday
    if dow == 5 {
        return day_start + (2 * SECONDS_PER_DAY)
    }

    # If Sunday (6), add 1 day to Monday
    if dow == 6 {
        return day_start + SECONDS_PER_DAY
    }

    # Already a weekday
    return day_start
}
