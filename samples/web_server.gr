# Simple Web Server in Glang
# This is an experimental implementation to test language capabilities

# Try without imports first to see basic functionality
# import "io" as io
# import "json" as json

# Configuration - try with simple values first
host = "localhost"
port = 8080
max_connections = 10

# HTTP Response builder - simplified version
func create_response(status_code, content_type, body) {
    status_line = "HTTP/1.1 " + status_code.to_string() + " OK\r\n"

    # Simple headers
    header_lines = "Content-Type: " + content_type + "\r\n"
    header_lines = header_lines + "Server: Glang/1.0\r\n"
    header_lines = header_lines + "Content-Length: " + body.length().to_string() + "\r\n"

    # Complete response
    response = status_line + header_lines + "\r\n" + body
    return response
}

# Parse HTTP request (simplified)
func parse_request(request_text) {
    lines = request_text.split("\n")

    if lines.size() == 0 {
        return [:error, "Empty request"]
    }

    # Parse request line: "GET /path HTTP/1.1"
    request_line = lines[0].trim()
    parts = request_line.split(" ")

    if parts.size() < 3 {
        return [:error, "Invalid request line"]
    }

    request_data = {
        "method": parts[0],
        "path": parts[1],
        "version": parts[2],
        "headers": {},
        "body": ""
    }

    # Parse headers (simplified)
    header_index = 1
    while header_index < lines.size() {
        line = lines[header_index].trim()

        if line == "" {
            # Empty line marks end of headers
            break
        }

        if line.contains(":") {
            header_parts = line.split(":")
            key = header_parts[0].trim()
            value = header_parts[1].trim()
            request_data["headers"][key] = value
        }

        header_index = header_index + 1
    }

    return [:ok, request_data]
}

# Route handler for home page
func handle_home() {
    html = "<html><head><title>Glang Web Server</title></head>" +
           "<body><h1>Welcome to Glang!</h1>" +
           "<p>This web server is written in Glang programming language.</p>" +
           "<ul>" +
           "<li><a href='/'>Home</a></li>" +
           "<li><a href='/api/status'>API Status</a></li>" +
           "<li><a href='/api/time'>Current Time</a></li>" +
           "</ul></body></html>"

    headers = {
        "Content-Type": "text/html; charset=utf-8",
        "Server": "Glang/1.0"
    }

    return [:ok, create_response(200, headers, html)]
}

# Route handler for API status
func handle_api_status() {
    status_data = {
        "status": "running",
        "language": "glang",
        "version": "1.0.0",
        "uptime": "unknown"  # Would need system time functions
    }

    json_response = json.encode(status_data)

    headers = {
        "Content-Type": "application/json",
        "Server": "Glang/1.0"
    }

    return [:ok, create_response(200, headers, json_response)]
}

# Route handler for current time
func handle_api_time() {
    # This would need time module
    time_data = {
        "current_time": "2025-01-15T14:30:00Z",  # Hardcoded for now
        "timezone": "UTC",
        "timestamp": 1737900600
    }

    json_response = json.encode(time_data)

    headers = {
        "Content-Type": "application/json",
        "Server": "Glang/1.0"
    }

    return [:ok, create_response(200, headers, json_response)]
}

# 404 Not Found handler
func handle_not_found(path) {
    html = "<html><head><title>404 Not Found</title></head>" +
           "<body><h1>404 - Page Not Found</h1>" +
           "<p>The requested path '" + path + "' was not found on this server.</p>" +
           "<a href='/'>Go Home</a></body></html>"

    headers = {
        "Content-Type": "text/html; charset=utf-8",
        "Server": "Glang/1.0"
    }

    return [:ok, create_response(404, headers, html)]
}

# Router - dispatch requests to handlers
func route_request(request) {
    path = request["path"]
    method = request["method"]

    # Only handle GET requests for now
    if method != "GET" {
        return [:error, "Method not supported: " + method]
    }

    # Route to appropriate handler
    if path == "/" {
        return handle_home()
    } else if path == "/api/status" {
        return handle_api_status()
    } else if path == "/api/time" {
        return handle_api_time()
    } else {
        return handle_not_found(path)
    }
}

# Process a single client connection
func handle_client(client_data) {
    # Parse the HTTP request
    parse_result = parse_request(client_data)

    response = match parse_result {
        [:ok, request] => {
            # Route the request
            route_result = route_request(request)

            match route_result {
                [:ok, http_response] => http_response,
                [:error, msg] => {
                    # Return 500 error
                    error_html = "<html><body><h1>500 Internal Server Error</h1><p>" + msg + "</p></body></html>"
                    headers = {"Content-Type": "text/html", "Server": "Glang/1.0"}
                    create_response(500, headers, error_html)
                },
                _ => {
                    error_html = "<html><body><h1>500 Internal Server Error</h1><p>Unknown error</p></body></html>"
                    headers = {"Content-Type": "text/html", "Server": "Glang/1.0"}
                    create_response(500, headers, error_html)
                }
            }
        },
        [:error, msg] => {
            # Return 400 Bad Request
            error_html = "<html><body><h1>400 Bad Request</h1><p>" + msg + "</p></body></html>"
            headers = {"Content-Type": "text/html", "Server": "Glang/1.0"}
            create_response(400, headers, error_html)
        },
        _ => {
            error_html = "<html><body><h1>500 Internal Server Error</h1><p>Request parsing failed</p></body></html>"
            headers = {"Content-Type": "text/html", "Server": "Glang/1.0"}
            create_response(500, headers, error_html)
        }
    }

    return response
}

# Main server loop (simplified - missing actual network I/O)
func start_server() {
    print("Starting Glang Web Server...")
    print("Host: " + config["host"])
    print("Port: " + config["port"].to_string())
    print("Max Connections: " + config["max_connections"].to_string())
    print("")
    print("Missing features needed for full implementation:")
    print("1. TCP socket creation and binding")
    print("2. Socket listening and accepting connections")
    print("3. Network I/O (reading from/writing to sockets)")
    print("4. Concurrent connection handling (threads/async)")
    print("5. System time functions")
    print("6. Signal handling (SIGINT for graceful shutdown)")
    print("7. Logging system")
    print("")
    print("Current implementation can parse HTTP and generate responses!")

    # Simulate handling a few requests to test the logic
    test_requests()
}

# Test the HTTP handling logic with sample requests
func test_requests() {
    print("Testing HTTP request handling...")
    print("================================")

    # Test 1: Home page request
    sample_request1 = "GET / HTTP/1.1\r\nHost: localhost:8080\r\nUser-Agent: TestClient/1.0\r\n\r\n"
    print("Test 1: GET /")
    response1 = handle_client(sample_request1)
    print("Response length: " + response1.length().to_string() + " characters")
    print("")

    # Test 2: API status request
    sample_request2 = "GET /api/status HTTP/1.1\r\nHost: localhost:8080\r\nAccept: application/json\r\n\r\n"
    print("Test 2: GET /api/status")
    response2 = handle_client(sample_request2)
    print("Response length: " + response2.length().to_string() + " characters")
    print("")

    # Test 3: 404 request
    sample_request3 = "GET /nonexistent HTTP/1.1\r\nHost: localhost:8080\r\n\r\n"
    print("Test 3: GET /nonexistent")
    response3 = handle_client(sample_request3)
    print("Response length: " + response3.length().to_string() + " characters")
    print("")

    # Test 4: Invalid request
    sample_request4 = "INVALID\r\n\r\n"
    print("Test 4: Invalid request")
    response4 = handle_client(sample_request4)
    print("Response length: " + response4.length().to_string() + " characters")
    print("")

    print("All tests completed!")
    print("To see actual responses, you could write them to files:")
    print("  - Use io.open() to create response files")
    print("  - Write response content for inspection")
}

# Entry point
print("Glang Web Server Experiment")
print("===========================")
start_server()