# Graph Configure Block Demo
# Demonstrates the configure block inside graph declarations

# ============================================================================
# READABLE CONFIGURATION
# Generates getter methods: configure { readable: [:x, :y] }
# ============================================================================

graph Point {
    configure { readable: [:x, :y] }   # Generates x() and y() getters

    x: 0
    y: 0
}

p = Point.clone()
p.x = 10
p.y = 20
print("Point coordinates via getters:")
print("x = " + p.x().to_string())   # Uses generated getter
print("y = " + p.y().to_string())   # Uses generated getter

# ============================================================================
# WRITABLE CONFIGURATION
# Generates setter methods: configure { writable: :name }
# ============================================================================

graph Person {
    configure { writable: :name }    # Generates set_name(value) setter

    name: "Unknown"
}

person = Person.clone()
print("Person before: " + person.name)
person.set_name("Alice")  # Uses generated setter
print("Person after: " + person.name)

# ============================================================================
# ACCESSIBLE CONFIGURATION
# Shorthand for both readable and writable: configure { accessible: :value }
# ============================================================================

graph Counter {
    configure { accessible: :count }   # Generates count() getter AND set_count(value) setter

    count: 0

    fn increment() {
        count = count + 1
    }
}

counter = Counter.clone()
print("Counter initial: " + counter.count().to_string())
counter.increment()
counter.increment()
print("Counter after 2 increments: " + counter.count().to_string())
counter.set_count(100)
print("Counter after set_count(100): " + counter.count().to_string())

# ============================================================================
# SINGLE SYMBOL SYNTAX
# For single items, the list is optional: readable: :x is same as readable: [:x]
# ============================================================================

graph Simple {
    configure { readable: :value }   # Single symbol - no list needed

    value: 42
}

s = Simple.clone()
print("Simple value: " + s.value().to_string())

# ============================================================================
# COMBINING CONFIGURATIONS
# Multiple options work together
# ============================================================================

graph Rectangle {
    configure {
        readable: [:area, :perimeter]
        accessible: [:width, :height]
    }

    width: 0
    height: 0

    fn area() {
        return width * height
    }

    fn perimeter() {
        return 2 * (width + height)
    }
}

rect = Rectangle.clone()
rect.set_width(5)
rect.set_height(3)
print("Rectangle " + rect.width().to_string() + "x" + rect.height().to_string())
print("Area: " + rect.area().to_string())
print("Perimeter: " + rect.perimeter().to_string())

# ============================================================================
# CUSTOM METHODS OVERRIDE GENERATED ONES
# User-defined methods take precedence over generated ones
# ============================================================================

graph SmartCounter {
    configure { readable: :value }

    value: 0

    # Custom getter that formats the value
    fn value() {
        return "Count: " + value.to_string()
    }
}

sc = SmartCounter.clone()
sc.value = 42
print("SmartCounter value: " + sc.value())  # Uses custom method

# ============================================================================
# PRIVATE METHODS USE priv fn
# For privacy, use the existing `priv fn` keyword (not configure)
# ============================================================================

graph BankAccount {
    configure { readable: :account_number }

    account_number: "12345"
    balance: 1000

    # Private method - use priv fn
    priv fn calculate_interest() {
        return balance * 0.05   # 5% interest
    }

    fn deposit(amount) {
        balance = balance + amount
        return balance
    }

    fn get_balance_with_interest() {
        # Can call private method from within the graph
        return balance + _calculate_interest()
    }

    fn get_statement() {
        return "Account " + account_number + ": $" + balance.to_string()
    }
}

account = BankAccount.clone()
print("Bank account demo:")
print(account.get_statement())
account.deposit(500)
print("After deposit of $500:")
print(account.get_statement())
print("Balance with interest: $" + account.get_balance_with_interest().to_string())

print("Graph configure block demo complete!")
