# Graph Directives Demo
# Demonstrates Phase 4 access control directives

# ============================================================================
# READABLE DIRECTIVE
# Generates getter methods: readable :x, :y
# ============================================================================

graph Point {
    readable :x, :y   # Generates x() and y() getters

    x: 0
    y: 0
}

p = Point.clone()
p.x = 10
p.y = 20
print("Point coordinates via getters:")
print("x = " + p.x().to_string())   # Uses generated getter
print("y = " + p.y().to_string())   # Uses generated getter

# ============================================================================
# WRITABLE DIRECTIVE
# Generates setter methods: writable :name
# ============================================================================

graph Person {
    writable :name    # Generates set_name(value) setter

    name: "Unknown"
}

person = Person.clone()
print("Person before: " + person.name)
person.set_name("Alice")  # Uses generated setter
print("Person after: " + person.name)

# ============================================================================
# ACCESSIBLE DIRECTIVE
# Shorthand for both readable and writable: accessible :value
# ============================================================================

graph Counter {
    accessible :count   # Generates count() getter AND set_count(value) setter

    count: 0

    fn increment() {
        count = count + 1
    }
}

counter = Counter.clone()
print("Counter initial: " + counter.count().to_string())
counter.increment()
counter.increment()
print("Counter after 2 increments: " + counter.count().to_string())
counter.set_count(100)
print("Counter after set_count(100): " + counter.count().to_string())

# ============================================================================
# COMBINING DIRECTIVES
# Multiple directives work together
# ============================================================================

graph Rectangle {
    readable :area, :perimeter
    accessible :width, :height

    width: 0
    height: 0

    fn area() {
        return width * height
    }

    fn perimeter() {
        return 2 * (width + height)
    }
}

rect = Rectangle.clone()
rect.set_width(5)
rect.set_height(3)
print("Rectangle " + rect.width().to_string() + "x" + rect.height().to_string())
print("Area: " + rect.area().to_string())
print("Perimeter: " + rect.perimeter().to_string())

# ============================================================================
# CUSTOM METHODS OVERRIDE DIRECTIVES
# User-defined methods take precedence over generated ones
# ============================================================================

graph SmartCounter {
    readable :value

    value: 0

    # Custom getter that formats the value
    fn value() {
        return "Count: " + value.to_string()
    }
}

sc = SmartCounter.clone()
sc.value = 42
print("SmartCounter value: " + sc.value())  # Uses custom method

# ============================================================================
# PRIVATE DIRECTIVE
# Restricts access to within the graph only: private :secret
# ============================================================================

graph BankAccount {
    private :balance, :calculate_interest   # Only accessible inside the graph
    readable :account_number

    account_number: "12345"
    balance: 1000

    fn calculate_interest() {
        return balance * 0.05   # 5% interest
    }

    fn deposit(amount) {
        balance = balance + amount
        return balance
    }

    fn withdraw(amount) {
        if amount > balance {
            return "Insufficient funds"
        }
        balance = balance - amount
        return balance
    }

    fn get_balance_with_interest() {
        # Can access private method/property from inside the graph
        return balance + calculate_interest()
    }

    fn get_statement() {
        return "Account " + account_number + ": $" + balance.to_string()
    }
}

account = BankAccount.clone()
print("Bank account demo:")
print(account.get_statement())
account.deposit(500)
print("After deposit of $500:")
print(account.get_statement())
print("Balance with interest: $" + account.get_balance_with_interest().to_string())

# Note: The following would fail if uncommented (private access):
# bad = account.balance      # Error: Cannot access private property
# bad = account.calculate_interest()  # Error: Cannot call private method

print("Graph directives demo complete!")
