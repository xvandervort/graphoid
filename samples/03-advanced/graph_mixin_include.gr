# Phase 22: Mixin pattern with include()
# Allows copying methods from one graph to another without inheritance

# Define a mixin with common functionality
graph Comparable {
    fn equals(other) {
        return self.value == other.value
    }

    fn not_equals(other) {
        return self.value != other.value
    }

    fn greater_than(other) {
        return self.value > other.value
    }

    # Private method - should NOT be included
    fn _internal_compare(other) {
        return self.value - other.value
    }
}

# Define a class that uses the mixin
graph Point {
    value: 0
    x: 0
    y: 0

    fn new(px, py) {
        p = self.clone()
        p.x = px
        p.y = py
        p.value = px + py
        return p
    }

    fn to_string() {
        return "Point(" + x.to_string() + ", " + y.to_string() + ")"
    }
}

# Include the Comparable mixin
included = Point.include(Comparable)
print("Included methods: " + included.to_string())

# Create instances
p1 = Point.new(1, 2)
p2 = Point.new(3, 4)
p3 = Point.new(1, 2)

# Test the mixed-in methods
print("p1: " + p1.to_string() + " (value=" + p1.value.to_string() + ")")
print("p2: " + p2.to_string() + " (value=" + p2.value.to_string() + ")")
print("p3: " + p3.to_string() + " (value=" + p3.value.to_string() + ")")

print("p1.equals(p3): " + p1.equals(p3).to_string())
print("p1.equals(p2): " + p1.equals(p2).to_string())
print("p1.not_equals(p2): " + p1.not_equals(p2).to_string())
print("p2.greater_than(p1): " + p2.greater_than(p1).to_string())
