# Class-Like Graphs: Static Methods Demo (Phase 20)
#
# Demonstrates static methods using the `static fn` keyword.
# Static methods are called on the class (graph) itself, not on instances.
# They do NOT have access to `self`.

print("=== Static Methods Demo ===")
print("")

# -----------------------------------------------------------------------------
# Basic Static Method (Factory Pattern)
# -----------------------------------------------------------------------------
print("--- Factory Pattern ---")

graph Circle {
    radius: 0

    # Instance method - requires `self`
    get area() {
        return 3.14159 * radius * radius
    }

    # Static method - called on Circle, creates instances
    static fn create_unit_circle() {
        c = Circle.clone()
        c.radius = 1
        return c
    }

    static fn create_with_radius(r) {
        c = Circle.clone()
        c.radius = r
        return c
    }
}

# Use factory methods
unit = Circle.create_unit_circle()
print("Unit circle radius: " + unit.radius.to_string())
print("Unit circle area: " + unit.area.to_string())

big = Circle.create_with_radius(10)
print("Big circle radius: " + big.radius.to_string())
print("Big circle area: " + big.area.to_string())

print("")

# -----------------------------------------------------------------------------
# Static Method vs Instance Method
# -----------------------------------------------------------------------------
print("--- Static vs Instance Methods ---")

graph Counter {
    _value: 0
    _count: 0  # Tracks number of counters

    # Instance method - works on a specific counter
    fn increment() {
        _value = _value + 1
    }

    get value() {
        return _value
    }

    # Static method - factory that tracks count
    static fn create(initial) {
        c = Counter.clone()
        c._value = initial
        Counter._count = Counter._count + 1
        return c
    }

    # Static method - gets the count (no self needed)
    static fn get_count() {
        return Counter._count
    }
}

c1 = Counter.create(0)
c2 = Counter.create(10)
c3 = Counter.create(100)

c1.increment()
c1.increment()
c2.increment()

print("Counter 1 value: " + c1.value.to_string())
print("Counter 2 value: " + c2.value.to_string())
print("Counter 3 value: " + c3.value.to_string())
print("Total counters created: " + Counter.get_count().to_string())

print("")

# -----------------------------------------------------------------------------
# Static Methods with Inheritance
# -----------------------------------------------------------------------------
print("--- Static Methods with Inheritance ---")

graph Shape {
    name: "shape"

    static fn describe() {
        return "I am a Shape class"
    }
}

graph Rectangle from Shape {
    name: "rectangle"
    width: 0
    height: 0

    static fn describe() {
        return "I am a Rectangle class"
    }

    static fn create(w, h) {
        r = Rectangle.clone()
        r.width = w
        r.height = h
        return r
    }

    get area() {
        return width * height
    }
}

# Call static methods on classes
print("Shape.describe(): " + Shape.describe())
print("Rectangle.describe(): " + Rectangle.describe())

# Create instances with static factory
rect = Rectangle.create(10, 5)
print("Rectangle area: " + rect.area.to_string())

print("")

# -----------------------------------------------------------------------------
# Static Method for Utility Functions
# -----------------------------------------------------------------------------
print("--- Utility Functions ---")

graph Math {
    static fn max(a, b) {
        if a > b {
            return a
        }
        return b
    }

    static fn min(a, b) {
        if a < b {
            return a
        }
        return b
    }

    static fn abs(n) {
        if n < 0 {
            return 0 - n
        }
        return n
    }
}

print("Math.max(5, 10) = " + Math.max(5, 10).to_string())
print("Math.min(5, 10) = " + Math.min(5, 10).to_string())
print("Math.abs(-42) = " + Math.abs(-42).to_string())

print("")
print("=== Demo Complete ===")
