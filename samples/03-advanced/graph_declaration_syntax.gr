# Graph Declaration Syntax Demo
# Demonstrates the new unified graph declaration syntax with intrinsic naming

# Simple graph with properties only
graph Point {
    x: 0
    y: 0
}

# Create an instance and modify it
p = Point.clone()
p.x = 10
p.y = 20
print("Point created with x=10, y=20")
print(p.x)
print(p.y)

# Graph with properties and methods - using IMPLICIT SELF (Phase 2)
# No need to write self. everywhere!
graph Counter {
    count: 0

    fn increment() {
        count = count + 1  # Implicit self - same as: self.count = self.count + 1
    }

    fn decrement() {
        count = count - 1
    }

    fn reset() {
        count = 0
    }

    fn value() {
        return count  # Implicit read - same as: return self.count
    }
}

# Test Counter
c = Counter.clone()
c.increment()
c.increment()
c.increment()
print("Counter after 3 increments:")
print(c.value())
c.decrement()
print("Counter after decrement:")
print(c.value())

# Inheritance example - with implicit self throughout
graph Animal {
    name: "unnamed"
    sound: "..."

    fn speak() {
        print(name + " says: " + sound)  # Implicit self for properties
    }

    fn greet() {
        print("Hello, I'm " + name)
    }
}

graph Dog from Animal {
    sound: "woof!"
    breed: "unknown"

    fn fetch() {
        print(name + " fetches the ball!")
    }

    # Implicit method call - call another method without self.
    fn play() {
        fetch()  # Same as: self.fetch()
        speak()  # Inherited method, also works!
    }
}

graph Cat from Animal {
    sound: "meow!"
    indoor: true

    fn purr() {
        print(name + " purrs contentedly")
    }
}

# Test inheritance
fido = Dog.clone()
fido.name = "Fido"
fido.breed = "Labrador"
fido.greet()
fido.speak()
fido.fetch()

# Test implicit method call
print("Testing implicit method call (play calls fetch and speak):")
fido.play()

whiskers = Cat.clone()
whiskers.name = "Whiskers"
whiskers.greet()
whiskers.speak()
whiskers.purr()

# Graph with utility methods
graph MathHelper {
    fn square(x) {
        return x * x
    }

    fn cube(x) {
        return x * x * x
    }
}

# Use methods (need instance for now)
math = MathHelper.clone()
print("5 squared:")
print(math.square(5))
print("3 cubed:")
print(math.cube(3))

print("Graph declaration syntax demo complete!")
