# Class-Like Graphs in Graphoid
#
# Graphoid is not an object-oriented language, but graphs can have attached
# methods, simulating class-like behavior. This pattern enables:
# - Encapsulation of state (data as graph nodes)
# - Methods that operate on that state
# - Instance creation via cloning
# - Method chaining

# Define a Counter "class" using graph declaration syntax
graph Counter {
    count: 0

    # The .new() method is a convention for creating instances
    fn new(initial) {
        instance = self.clone()  # Clone the prototype
        instance.count = initial
        return instance
    }

    fn increment() {
        count = count + 1  # Implicit self
        return self
    }

    fn decrement() {
        count = count - 1
        return self
    }

    fn value() {
        return count
    }

    fn reset() {
        count = 0
        return self
    }
}

# Create instances using .new()
c1 = Counter.new(0)
c2 = Counter.new(100)

# Individual operations (mutations persist to the variable)
c1.increment()
c1.increment()
c1.increment()

c2.decrement()
c2.decrement()

print("c1 after 3 increments: " + c1.value().to_string())
print("c2 after 2 decrements: " + c2.value().to_string())

# Method chaining (requires explicit assignment for full persistence)
c3 = Counter.new(10)
c3 = c3.increment().increment().decrement()
print("c3 after +1, +1, -1: " + c3.value().to_string())

# The prototype is unchanged
print("Counter prototype: " + Counter.value().to_string())

# Note: For simple operations, no assignment needed:
c4 = Counter.new(5)
c4.increment()  # This persists directly to c4
print("c4 after single increment: " + c4.value().to_string())
