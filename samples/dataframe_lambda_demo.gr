#!/usr/bin/env glang

# Complete demonstration of lambda-powered DataFrame capabilities
# This shows what becomes possible with lambda support

print("ğŸš€ LAMBDA-POWERED DATAFRAME CAPABILITIES DEMONSTRATION")
print("====================================================")

print("\n=== 1. Lambda Functions Work Perfectly! ===")

# Demonstrate lambda support
numbers = [75000, 65000, 95000, 70000, 80000]
names = ["Alice", "Bob", "Charlie", "Diana", "Eve"]

print("Original salaries: " + numbers.to_string())

# Column transformation with lambda
salary_boost = numbers.map(x => x * 1.10)
print("After 10% raise: " + salary_boost.to_string())

# Advanced filtering with lambda
high_earners = numbers.filter(x => x > 75000)
print("High earners (>$75K): " + high_earners.to_string())

# Complex lambda expressions
salary_grades = numbers.map(x => {
    if x < 70000 { return "Entry" }
    else if x < 85000 { return "Standard" }
    else { return "Premium" }
})
print("Salary grades: " + salary_grades.to_string())

print("\n=== 2. DataFrame Structure Creation ===")

# Create DataFrame structure manually (since file loading has issues)
employees = {
    "_type": "dataframe",
    "_columns": ["name", "salary", "department"],
    "_row_count": 5
}

# Initialize columns
employees["name"] = ["Alice Johnson", "Bob Smith", "Charlie Brown", "Diana Prince", "Eve Adams"]
employees["salary"] = [75000, 65000, 95000, 70000, 80000]
employees["department"] = ["Engineering", "Engineering", "Management", "Marketing", "Engineering"]

print("Employee DataFrame created with " + employees["_row_count"].to_string() + " rows")
print("Columns: " + employees["_columns"].to_string())

print("\n=== 3. Lambda-Powered Column Transformations ===")

# Transform salaries with lambda (10% raise)
raise_func = x => x * 1.10
boosted_salaries = employees["salary"].map(raise_func)
print("Salaries after 10% raise: " + boosted_salaries.to_string())

# Transform names with lambda (uppercase)
upper_func = x => x.upper()
upper_names = employees["name"].map(upper_func)
print("Names in uppercase: " + upper_names.to_string())

# Create salary categories with complex lambda
category_func = x => {
    if x < 70000 { return "Entry Level" }
    else if x < 85000 { return "Mid Level" }
    else { return "Senior Level" }
}
salary_categories = employees["salary"].map(category_func)
print("Salary categories: " + salary_categories.to_string())

print("\n=== 4. Advanced Filtering with Lambdas ===")

# Find indices of high-earning engineers
indices = [].upto(employees["_row_count"] - 1)

# Filter for engineering high earners
engineer_high_earner_indices = indices.filter(i =>
    employees["salary"][i] > 70000 && employees["department"][i] == "Engineering"
)
print("Engineering high-earners indices: " + engineer_high_earner_indices.to_string())

# Get their names
engineer_high_earner_names = engineer_high_earner_indices.map(i => employees["name"][i])
print("Engineering high-earners: " + engineer_high_earner_names.to_string())

print("\n=== 5. Statistical Analysis with Lambdas ===")

# Custom aggregation functions
total_salary = employees["salary"].sum()
avg_salary = total_salary / employees["salary"].size()
salary_range = employees["salary"].max() - employees["salary"].min()

print("Total payroll: $" + total_salary.to_string())
print("Average salary: $" + avg_salary.to_string())
print("Salary range: $" + salary_range.to_string())

# Count by department using lambdas
engineering_count = employees["department"].filter(x => x == "Engineering").size()
management_count = employees["department"].filter(x => x == "Management").size()
marketing_count = employees["department"].filter(x => x == "Marketing").size()

print("\nDepartment counts:")
print("  Engineering: " + engineering_count.to_string())
print("  Management: " + management_count.to_string())
print("  Marketing: " + marketing_count.to_string())

print("\n=== 6. Custom Business Logic with Lambdas ===")

# Calculate bonuses based on complex business rules
bonus_calculator = salary => {
    base_bonus = salary * 0.05  # 5% base
    if salary > 80000 {
        base_bonus = base_bonus * 1.5  # 50% bonus for high earners
    }
    return base_bonus
}

bonuses = employees["salary"].map(bonus_calculator)
print("Calculated bonuses: " + bonuses.to_string())

# Performance ratings based on salary and department
rating_func = i => {
    salary = employees["salary"][i]
    dept = employees["department"][i]

    if dept == "Management" && salary > 90000 { return "Executive" }
    else if dept == "Engineering" && salary > 75000 { return "Senior Engineer" }
    else if salary > 70000 { return "Experienced" }
    else { return "Standard" }
}

ratings = indices.map(rating_func)
print("Performance ratings: " + ratings.to_string())

print("\n=== 7. Data Validation with Lambdas ===")

# Validation rules using lambdas
valid_salary = employees["salary"].filter(x => x > 0 && x < 200000)
valid_names = employees["name"].filter(x => x.size() > 0)

print("Valid salaries count: " + valid_salary.size().to_string() + "/" + employees["salary"].size().to_string())
print("Valid names count: " + valid_names.size().to_string() + "/" + employees["name"].size().to_string())

# Find outliers (more than 1.5 times the average)
outlier_threshold = avg_salary * 1.5
outliers = employees["salary"].filter(x => x > outlier_threshold)
print("Salary outliers (>$" + outlier_threshold.to_string() + "): " + outliers.to_string())

print("\n=== 8. Complex Data Transformations ===")

# Create summary records using lambdas
summary_func = i => {
    return employees["name"][i] + " (" +
           employees["department"][i] + "): $" +
           employees["salary"][i].to_string()
}

employee_summaries = indices.map(summary_func)
print("Employee summaries:")
for summary in employee_summaries {
    print("  " + summary)
}

print("\n=== RESULTS SUMMARY ===")
print("âœ… Column transformations with custom lambdas")
print("âœ… Advanced filtering with complex conditions")
print("âœ… Statistical analysis with lambda aggregations")
print("âœ… Custom business logic implementation")
print("âœ… Data validation using lambda predicates")
print("âœ… Complex data transformations")

print("\nğŸ‰ LAMBDA SUPPORT TRANSFORMS DATAFRAMES!")
print("DataFrames can now handle:")
print("â€¢ Custom transformations: x => x * 1.1")
print("â€¢ Complex filtering: x => x > threshold && condition")
print("â€¢ Business rules: salary => calculate_bonus(salary)")
print("â€¢ Statistical analysis: data => custom_aggregation(data)")
print("â€¢ Data validation: value => is_valid(value)")

print("\nğŸš€ This makes DataFrames competitive with pandas!")
print("ğŸ”¥ Revolutionary data analysis capabilities unlocked!")