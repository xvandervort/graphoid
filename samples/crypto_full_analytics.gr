# Comprehensive Cryptocurrency Analytics
# Working within Glang's current limitations

import "io" as io

print("ðŸ“Š Comprehensive Cryptocurrency Analytics")
print("=========================================")

# Load CSV file
string content = io.read_file("crypto_history.csv")
list<string> lines = content.split("\n")

print("âœ… Loaded " + lines.size().to_string() + " lines")

# Data collection arrays (avoiding hashes due to key limitations)
list<string> btc_prices = []
list<string> ltc_prices = []
list<string> eth_prices = []
list<string> dates = []

num total_records = 0

print("ðŸ”„ Processing data...")

# Parse all data
num i = 1  # Skip header
while i < lines.size() {
    string line = lines[i].trim()

    if line.length() > 0 {
        list<string> fields = line.split(",")

        if fields.size() >= 5 {
            string date = fields[0]
            string symbol = fields[2]
            string price_str = fields[3]

            dates.append(date)
            total_records = total_records + 1

            if symbol == "BTC" {
                btc_prices.append(price_str)
            } else {
                if symbol == "LTC" {
                    ltc_prices.append(price_str)
                } else {
                    if symbol == "ETH" {
                        eth_prices.append(price_str)
                    }
                }
            }
        }
    }

    i = i + 1
}

print("âœ… Processed " + total_records.to_string() + " records")

# Function to analyze price data (simulate function with manual calculation)
print("\nðŸ’° Bitcoin (BTC) Analysis:")
print("==========================")

if btc_prices.size() > 0 {
    # Convert prices to numbers for analysis
    num btc_total = 0
    num btc_min = btc_prices[0].to_num()
    num btc_max = btc_prices[0].to_num()

    num j = 0
    while j < btc_prices.size() {
        num current_price = btc_prices[j].to_num()
        btc_total = btc_total + current_price

        if current_price < btc_min {
            btc_min = current_price
        }
        if current_price > btc_max {
            btc_max = current_price
        }

        j = j + 1
    }

    num btc_avg = btc_total / btc_prices.size()
    num btc_first = btc_prices[0].to_num()
    num btc_last = btc_prices[btc_prices.size() - 1].to_num()
    num btc_change = btc_last - btc_first
    num btc_percent = (btc_change / btc_first) * 100

    print("ðŸ“Š Records: " + btc_prices.size().to_string())
    print("ðŸ’µ Min Price: $" + btc_min.to_string())
    print("ðŸ’µ Max Price: $" + btc_max.to_string())
    print("ðŸ’µ Avg Price: $" + btc_avg.to_string())
    print("ðŸ“ˆ Total Change: " + btc_percent.to_string() + "%")
}

print("\nðŸ’° Litecoin (LTC) Analysis:")
print("===========================")

if ltc_prices.size() > 0 {
    # Convert prices to numbers for analysis
    num ltc_total = 0
    num ltc_min = ltc_prices[0].to_num()
    num ltc_max = ltc_prices[0].to_num()

    num k = 0
    while k < ltc_prices.size() {
        num ltc_current_price = ltc_prices[k].to_num()
        ltc_total = ltc_total + ltc_current_price

        if ltc_current_price < ltc_min {
            ltc_min = ltc_current_price
        }
        if ltc_current_price > ltc_max {
            ltc_max = ltc_current_price
        }

        k = k + 1
    }

    num ltc_avg = ltc_total / ltc_prices.size()
    num ltc_first = ltc_prices[0].to_num()
    num ltc_last = ltc_prices[ltc_prices.size() - 1].to_num()
    num ltc_change = ltc_last - ltc_first
    num ltc_percent = (ltc_change / ltc_first) * 100

    print("ðŸ“Š Records: " + ltc_prices.size().to_string())
    print("ðŸ’µ Min Price: $" + ltc_min.to_string())
    print("ðŸ’µ Max Price: $" + ltc_max.to_string())
    print("ðŸ’µ Avg Price: $" + ltc_avg.to_string())
    print("ðŸ“ˆ Total Change: " + ltc_percent.to_string() + "%")
}

print("\nðŸ’° Ethereum (ETH) Analysis:")
print("===========================")

if eth_prices.size() > 0 {
    # Convert prices to numbers for analysis
    num eth_total = 0
    num eth_min = eth_prices[0].to_num()
    num eth_max = eth_prices[0].to_num()

    num m = 0
    while m < eth_prices.size() {
        num eth_current_price = eth_prices[m].to_num()
        eth_total = eth_total + eth_current_price

        if eth_current_price < eth_min {
            eth_min = eth_current_price
        }
        if eth_current_price > eth_max {
            eth_max = eth_current_price
        }

        m = m + 1
    }

    num eth_avg = eth_total / eth_prices.size()
    num eth_first = eth_prices[0].to_num()
    num eth_last = eth_prices[eth_prices.size() - 1].to_num()
    num eth_change = eth_last - eth_first
    num eth_percent = (eth_change / eth_first) * 100

    print("ðŸ“Š Records: " + eth_prices.size().to_string())
    print("ðŸ’µ Min Price: $" + eth_min.to_string())
    print("ðŸ’µ Max Price: $" + eth_max.to_string())
    print("ðŸ’µ Avg Price: $" + eth_avg.to_string())
    print("ðŸ“ˆ Total Change: " + eth_percent.to_string() + "%")
}

# Portfolio analysis
print("\nðŸ† Performance Comparison:")
print("==========================")

if btc_prices.size() > 0 {
    if ltc_prices.size() > 0 {
        if eth_prices.size() > 0 {
    num btc_return = ((btc_prices[btc_prices.size() - 1].to_num() - btc_prices[0].to_num()) / btc_prices[0].to_num()) * 100
    num ltc_return = ((ltc_prices[ltc_prices.size() - 1].to_num() - ltc_prices[0].to_num()) / ltc_prices[0].to_num()) * 100
    num eth_return = ((eth_prices[eth_prices.size() - 1].to_num() - eth_prices[0].to_num()) / eth_prices[0].to_num()) * 100

    print("ðŸš€ Total Returns:")
    print("  BTC: " + btc_return.to_string() + "%")
    print("  LTC: " + ltc_return.to_string() + "%")
    print("  ETH: " + eth_return.to_string() + "%")

    # Find best performer
    string best_performer = "BTC"
    num best_return = btc_return

    if ltc_return > best_return {
        best_performer = "LTC"
        best_return = ltc_return
    }

    if eth_return > best_return {
        best_performer = "ETH"
        best_return = eth_return
    }

    print("ðŸ† Best Performer: " + best_performer + " (" + best_return.to_string() + "%)")
        }
    }
}

# Simple volatility analysis (standard deviation approximation)
print("\nðŸ“Š Volatility Analysis:")
print("=======================")

if btc_prices.size() > 0 {
    # Calculate daily changes for Bitcoin
    num btc_change_count = 0
    num btc_positive_days = 0

    num n = 1
    while n < btc_prices.size() {
        num today_price = btc_prices[n].to_num()
        num yesterday_price = btc_prices[n - 1].to_num()
        num daily_change_percent = ((today_price - yesterday_price) / yesterday_price) * 100

        if daily_change_percent > 0 {
            btc_positive_days = btc_positive_days + 1
        }

        btc_change_count = btc_change_count + 1
        n = n + 1
    }

    num btc_positive_ratio = (btc_positive_days / btc_change_count) * 100

    print("ðŸ“ˆ Bitcoin positive days: " + btc_positive_ratio.to_string() + "%")
}

# Summary
print("\nðŸ“… Date Range:")
print("==============")

if dates.size() > 0 {
    print("ðŸ“… Start: " + dates[0])
    print("ðŸ“… End: " + dates[dates.size() - 1])
    print("ðŸ“Š Trading Days: ~" + (dates.size() / 3).to_string())
}

print("\nâœ¨ Analysis Complete!")
print("=====================")
print("ðŸŽ¯ Processed " + total_records.to_string() + " records across 3 cryptocurrencies")
print("ðŸ“Š Calculated price ranges, returns, and performance metrics")
print("ðŸš€ Glang data analytics experiment successful!")