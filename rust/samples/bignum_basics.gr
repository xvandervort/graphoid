# BigNum Basics - Introduction to High-Precision Numbers
#
# This example demonstrates the fundamental concepts of Graphoid's bignum type,
# which provides arbitrary precision arithmetic beyond standard floating-point limits.

# ============================================================================
# Example 1: Explicit BigNum Declaration
# ============================================================================
# You can explicitly declare a variable as bignum even for small numbers

bignum small_but_precise = 42.0

# The value is stored with much higher precision than a regular num (f64)
# Regular num: ~15-17 decimal digits
# BigNum Float128: ~34 decimal digits

# ============================================================================
# Example 2: Automatic Type Detection for Large Numbers
# ============================================================================
# Graphoid automatically uses bignum for very large integers

very_large = 123456789012345678901234567890  # Too big for f64 precision

# This prevents precision loss that would occur with regular floating-point
# (In f64, large integers lose precision beyond 2^53 â‰ˆ 9 quadrillion)

# ============================================================================
# Example 3: Basic Arithmetic with BigNum
# ============================================================================

bignum a = 100.0
bignum b = 50.0

sum = a + b         # 150.0
difference = a - b  # 50.0
product = a * b     # 5000.0
quotient = a / b    # 2.0

# All results maintain high precision

# ============================================================================
# Example 4: Type Checking and Introspection
# ============================================================================

bignum value = 999.0

# Check if a value is bignum (returns true)
is_big = value.is_bignum()

# Get the type name as a string
type_str = value.to_string()  # Converts value to string representation

# ============================================================================
# Example 5: Integer vs Float Mode
# ============================================================================

# By default, bignum values are floating-point (like regular num)
bignum float_val = 123.456

# Use the :integer directive to work with integers
configure { precision: :high, :integer } {
    bignum int_val = 123.456  # Truncated to 123
    bignum another = 99.9     # Truncated to 99
    int_sum = int_val + another  # 222 (integer arithmetic)
}

# ============================================================================
# Example 6: Conversion Methods
# ============================================================================

bignum big = 12345.0

# Convert bignum to regular num (may lose precision if value is too large)
regular = big.to_num()

# Convert to integer (truncates decimal part)
int_version = big.to_int()

# Explicitly convert to arbitrary-precision integer
big_int = big.to_bigint()

# ============================================================================
# Key Takeaways
# ============================================================================
#
# 1. BigNum provides arbitrary precision beyond f64 limits
# 2. Large literals are automatically detected as bignum
# 3. You can explicitly declare bignum for guaranteed precision
# 4. BigNum works like num by default (floating-point)
# 5. Use :integer directive for integer arithmetic
# 6. Conversion methods allow moving between num and bignum types
#
# Next: See high_precision.gr for Float128 precision examples
#       See large_integer_arithmetic.gr for overflow handling
