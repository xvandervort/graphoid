# Large Integer Arithmetic - Working with Numbers Beyond Standard Limits
#
# Demonstrates how Graphoid automatically handles very large integers that exceed
# the standard 64-bit integer range, and how to convert between different numeric types.

# Example 1: Automatic overflow handling
# When multiplying large numbers, Graphoid automatically promotes to arbitrary-precision
configure { precision: :high, :integer } {
    bignum a = 9000000000000000000.0  # 9 quintillion (near 64-bit limit)
    bignum b = 2.0
    result1 = a * b  # Automatically uses unlimited precision for result
}

# Example 2: Addition beyond integer limits
# Even simple addition is automatically handled when the result exceeds limits
configure { precision: :high, :integer } {
    bignum a = 9223372036854775807.0  # Maximum 64-bit signed integer
    bignum b = 1.0
    result2 = a + b  # Result uses arbitrary precision (no overflow error!)
}

# Example 3: Converting back to standard integers
# You can convert large numbers back to standard integers if they fit
configure { precision: :high, :integer } {
    bignum big = 123456.0
    result3 = big.to_int()  # Converts to standard integer (checks for overflow)
}

# Example 4: Explicit conversion to arbitrary precision
# Force a number to use unlimited precision even if it fits in standard range
configure { precision: :high, :integer } {
    bignum small = 999.0
    result4 = small.to_bigint()  # Explicitly convert to unlimited precision
}

# Example 5: Truncating decimal values
# When converting floating-point to integer, decimal part is truncated
configure { precision: :high } {
    bignum f = 123.789
    result5 = f.to_int()  # Result is 123 (fractional part dropped)
}

# Key takeaway: Graphoid handles large numbers transparently - you don't need
# to worry about overflow errors or manually switch to different numeric types!
