# Time Module - Pure Graphoid Implementation
# All times are UTC timestamps (seconds since Unix epoch)
# Only system primitive needed: os.system_timestamp()

import "os"

# ==================== CONSTANTS ====================

# Seconds in various time units
SECONDS_PER_MINUTE = 60
SECONDS_PER_HOUR = 3600
SECONDS_PER_DAY = 86400
SECONDS_PER_WEEK = 604800

# Days in months (non-leap year)
DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

# ==================== CREATION ====================

# Get current time as UTC timestamp
fn now() {
    return os.system_timestamp()
}

# Get start of today (00:00:00 UTC)
fn today() {
    ts = now()
    # Round down to start of day
    days = ts // SECONDS_PER_DAY
    return days * SECONDS_PER_DAY
}

# Create time from date components (year, month, day)
fn from_date(year, month, day) {
    # Simple epoch calculation (good enough for 1970-2100)
    # Start from 1970-01-01

    # Count leap years from 1970 to year
    leap_years = 0
    y = 1970
    while y < year {
        if is_leap_year(y) {
            leap_years = leap_years + 1
        }
        y = y + 1
    }

    # Days from years
    years_diff = year - 1970
    days = years_diff * 365 + leap_years

    # Add days from months
    m = 1
    while m < month {
        days = days + days_in_month(m, year)
        m = m + 1
    }

    # Add remaining days
    days = days + (day - 1)

    return days * SECONDS_PER_DAY
}

# Helper: Check if year is a leap year
fn is_leap_year(year) {
    if year % 400 == 0 {
        return true
    }
    if year % 100 == 0 {
        return false
    }
    if year % 4 == 0 {
        return true
    }
    return false
}

# Helper: Get days in a specific month
fn days_in_month(month, year) {
    if month == 2 {
        if is_leap_year(year) {
            return 29
        }
        return 28
    }
    # Use array indexing (month is 1-based)
    return DAYS_IN_MONTH[month - 1]
}

# ==================== REPRESENTATIONS ====================

# Format timestamp as date string (YYYY-MM-DD)
fn as_date(ts, format) {
    components = timestamp_to_components(ts)
    year = components[0]
    month = components[1]
    day = components[2]

    # Default format: ISO (YYYY-MM-DD)
    if format == none {
        return year + "-" + pad_zero(month) + "-" + pad_zero(day)
    }

    # Long format: Month DD, YYYY
    if format == "long" {
        month_name = month_to_name(month)
        return month_name + " " + day + ", " + year
    }

    # Default
    return year + "-" + pad_zero(month) + "-" + pad_zero(day)
}

# Format timestamp as datetime string (YYYY-MM-DDTHH:MM:SSZ)
fn as_datetime(ts, format) {
    components = timestamp_to_components(ts)
    year = components[0]
    month = components[1]
    day = components[2]
    hour = components[3]
    minute = components[4]
    second = components[5]

    date_part = year + "-" + pad_zero(month) + "-" + pad_zero(day)
    time_part = pad_zero(hour) + ":" + pad_zero(minute) + ":" + pad_zero(second)

    return date_part + "T" + time_part + "Z"
}

# Convert timestamp to [year, month, day, hour, minute, second]
fn timestamp_to_components(ts) {
    # Days since epoch
    total_seconds = ts
    days = total_seconds // SECONDS_PER_DAY
    remaining = total_seconds % SECONDS_PER_DAY

    # Time components
    hour = remaining // SECONDS_PER_HOUR
    remaining = remaining % SECONDS_PER_HOUR
    minute = remaining // SECONDS_PER_MINUTE
    second = remaining % SECONDS_PER_MINUTE

    # Date components (simplified - good for 1970-2100)
    year = 1970
    month = 1
    day = 1

    # Count through years
    while days >= 365 {
        year_days = 365
        if is_leap_year(year) {
            year_days = 366
        }

        if days >= year_days {
            days = days - year_days
            year = year + 1
        } else {
            break
        }
    }

    # Count through months
    while days > 0 {
        month_days = days_in_month(month, year)
        if days >= month_days {
            days = days - month_days
            month = month + 1
        } else {
            day = day + days
            break
        }
    }

    return [year, month, day, hour, minute, second]
}

# Helper: Pad single digit with zero
fn pad_zero(n) {
    if n < 10 {
        return "0" + n
    }
    return "" + n
}

# Helper: Convert month number to name
fn month_to_name(month) {
    names = ["January", "February", "March", "April", "May", "June",
             "July", "August", "September", "October", "November", "December"]
    return names[month - 1]
}

# ==================== ARITHMETIC ====================

# Add months (calendar-aware)
fn add_months(ts, n) {
    components = timestamp_to_components(ts)
    year = components[0]
    month = components[1]
    day = components[2]

    # Add months
    new_month = month + n
    new_year = year

    # Handle year overflow/underflow
    while new_month > 12 {
        new_month = new_month - 12
        new_year = new_year + 1
    }

    while new_month < 1 {
        new_month = new_month + 12
        new_year = new_year - 1
    }

    # Clamp day to valid range (e.g., Jan 31 + 1 month = Feb 28)
    max_day = days_in_month(new_month, new_year)
    new_day = day
    if new_day > max_day {
        new_day = max_day
    }

    return from_date(new_year, new_month, new_day)
}

# ==================== PREDICATES ====================

# Check if timestamp is a weekday (Monday-Friday)
fn is_weekday(ts) {
    day_of_week = get_day_of_week(ts)
    return day_of_week >= 1 && day_of_week <= 5
}

# Check if timestamp is a weekend (Saturday-Sunday)
fn is_weekend(ts) {
    day_of_week = get_day_of_week(ts)
    return day_of_week == 0 || day_of_week == 6
}

# Get day of week (0=Sunday, 1=Monday, ..., 6=Saturday)
fn get_day_of_week(ts) {
    days = ts // SECONDS_PER_DAY
    # January 1, 1970 was a Thursday (day 4)
    return (days + 4) % 7
}

# ==================== NAVIGATION ====================

# Get start of week (Monday at 00:00:00)
fn start_of_week(ts) {
    day_of_week = get_day_of_week(ts)

    # Days to subtract to get to Monday
    if day_of_week == 0 {  # Sunday
        days_back = 6
    } else {
        days_back = day_of_week - 1
    }

    # Start of current day
    day_start = (ts // SECONDS_PER_DAY) * SECONDS_PER_DAY

    # Go back to Monday
    return day_start - (days_back * SECONDS_PER_DAY)
}

# Get end of month (last day at 23:59:59)
fn end_of_month(ts) {
    components = timestamp_to_components(ts)
    year = components[0]
    month = components[1]

    # Last day of month
    last_day = days_in_month(month, year)

    # Create timestamp for last day at 23:59:59
    last_day_start = from_date(year, month, last_day)
    return last_day_start + SECONDS_PER_DAY - 1
}

# ==================== BUSINESS LOGIC ====================

# Skip to next business day if currently on weekend
fn skip_weekends(ts) {
    if is_weekday(ts) {
        return ts
    }

    # If weekend, skip to Monday
    day_of_week = get_day_of_week(ts)
    if day_of_week == 0 {  # Sunday
        return ts + SECONDS_PER_DAY
    } else {  # Saturday
        return ts + (2 * SECONDS_PER_DAY)
    }
}

# ==================== MODULE METADATA ====================

# Module name
MODULE_NAME = "time"
MODULE_ALIAS = "tm"
